1:"$Sreact.fragment"
2:I[1942,["177","static/chunks/app/layout-7e9963bf811be36b.js"],"ThemeProvider"]
3:I[7121,[],""]
4:I[4581,[],""]
6:I[484,[],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[484,[],"ViewportBoundary"]
b:I[484,[],"MetadataBoundary"]
d:I[7123,[],""]
:HL["/_next/static/media/4cf2300e9c8272f7-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/4bd7a24b7976d4e6.css","style"]
0:{"P":null,"b":"05bjYGyiAumoEMBrfWHih","c":["","docs","internals","type-system",""],"q":"","i":false,"f":[[["",{"children":["docs",{"children":[["slug","internals/type-system","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4bd7a24b7976d4e6.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__variable_188709 __variable_9a8899 font-sans antialiased","children":["$","$L2",null,{"attribute":"class","defaultTheme":"dark","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:I[8428,["758","static/chunks/758-3cb69ce377cde046.js","121","static/chunks/121-aece4f809b101dc1.js","502","static/chunks/502-e809071f8789437b.js","689","static/chunks/689-4fcf9680fdc90283.js","870","static/chunks/app/docs/%5B%5B...slug%5D%5D/page-004ec69e3c86920a.js"],"DocsPageClient"]
f:T1e12,# Type System Specification

This document specifies InputLayer's type system for developers implementing or extending the language.

## Overview

A program is a sequence of declarations:

```ebnf
Decl       ::= TypeDecl | SchemaDecl | RuleDecl | FactDecl
```

- `type` - defines **value types** (aliases, refinements, record types)
- `+name(col: type, ...)` - defines **relation schemas** with typed columns
- Facts (`+name[(...)]`) - provide **base tuples** for relations
- Rules (`+name(...) <- body`) - define **derived tuples** for relations

## 1. Type Declarations (`type`)

### 1.1 Grammar

```ebnf
TypeDecl   ::= "type" TypeName ":" TypeExpr "."
TypeName   ::= UIdent          // capitalized, e.g. Email, User

TypeExpr   ::= SimpleType
             | RecordType

SimpleType ::= BaseType [Refinements]
BaseType   ::= "int" | "string" | "bool"
             | "list" "[" TypeExpr "]"
             | TypeName         // previously declared type

RecordType ::= "{" FieldList "}"
 FieldList  ::= Field ("," Field)*
Field      ::= FieldName ":" TypeExpr

 FieldName  ::= LIdent

Refinements ::= "(" Refinement ("," Refinement)* ")"
Refinement  ::= Ident "(" ... ")"   // opaque to the core language
```

### 1.2 Semantics

A `type` declaration introduces a **value type**. Types describe the **shape and constraints of values** but **do not define relations** by themselves.

### 1.3 Aliases and Refinements

```datalog
type Email: string(pattern("^[^@]+@[^@]+$"))
type Id:    int(range(1, 1000000))
type Tags:  list[string](not_empty)
```

Interpretation as refinement types:

- `Email` is a subset of `string`
- `Id` is a subset of `int`
- `Tags` is a subset of `list[string]`

Typing judgment:

```
G |- v : Email  =>  G |- v : string  and  v satisfies pattern("^[^@]+@[^@]+$")
```

The semantics of refinements (`pattern`, `range`, `not_empty`, ...) are implementation-defined.

### 1.4 Record Types

```datalog
type User: {
    id:      Id,
    name:    string(not_empty),
    email:   Email,
    my_tags: Tags
}
```

A **record type** `{ f1 : t1, ..., fn : tn }` is the type of records with named fields `fi` of types `ti`.

Important:
- `User` is a **value type**
- A single `User` value is a record with 4 fields
- This is *not* yet a relation; it's just a value type

## 2. Schema Declarations

A **relation schema** declares the structure of a relation (like a table).

### 2.1 Grammar

```ebnf
SchemaDecl ::= "+" RelName "(" ParamList ")" "."

RelName    ::= LIdent           // e.g. user, high_spender

ParamList  ::= Param ("," Param)*
Param      ::= ParamName ":" TypeExpr [Annotations]
ParamName  ::= LIdent

Annotations ::= Annotation+
Annotation  ::= "@" AnnotName
 AnnotName   ::= "key" | "unique" | "not_empty" | ...
```

### 2.2 Schema Declaration

```datalog
+user(
    id:      int,
    name:    string,
    email:   string
)
```

This declares a 3-ary relation:

```
user : int x string x string -> Bool
```

i.e. `user` is a subset of `int x string x string`.

Each parameter is a **column** in the relation.

### 2.3 Schema with Type References

```datalog
type Id:    int
type Email: string

+user(id: Id, name: string, email: Email)
```

## 3. Terms and Expressions

### 3.1 Grammar

```ebnf
Term       ::= Var
             | Constant

Var        ::= LIdent | UIdent
```

Constants are implementation-defined (ints, strings, bools, lists, ...).

## 4. Atoms, Facts, and Rules

### 4.1 Atoms

```ebnf
Atom        ::= RelName "(" ArgList? ")"
ArgList     ::= Arg ("," Arg)*
Arg         ::= Term
```

Example (positional):

```datalog
user(1, "Alice", "alice@example.com")
```

### 4.2 Facts

```ebnf
FactDecl    ::= "+" Atom "."
              | "+" RelName "[" TupleList "]" "."
```

Example:

```datalog
+user(1, "Alice", "alice@example.com")
+user[(2, "Bob", "bob@example.com"), (3, "Charlie", "charlie@example.com")]
```

### 4.3 Rules

```ebnf
RuleDecl    ::= ["+" ] HeadAtom "<-" Body "."
HeadAtom    ::= RelName "(" HeadArgList? ")"
HeadArgList ::= HeadArg ("," HeadArg)*
HeadArg     ::= Term

Body        ::= BodyAtom ("," BodyAtom)*
 BodyAtom    ::= Atom | Condition

Condition   ::= Term RelOp Term
RelOp       ::= "=" | "!=" | "<" | ">" | "<=" | ">="
```

### 4.4 Persistent vs Session Rules

```datalog
// Persistent rule (with + prefix) - stored and incrementally maintained
+admin_email(Email) <-
    user(_, _, Email),
    admin(Email)

// Session rule (no + prefix) - computed on-demand, not stored
temp_result(X, Y) <- source(X, Y), X > 10
```

## 5. Base vs Derived Relations

- **Base data (EDB)**: Relations populated via **facts only**
- **Derived data (IDB/views)**: Relations populated via **rules**

Both are still just **relations**:
- Schema gives the structure
- Facts and rules together define the relation's **extension**

SQL analogy:
- `+user(...) + facts` is analogous to `CREATE TABLE user (...) + INSERT INTO user .`
- `+admin_email(...) + rules` is analogous to `CREATE VIEW admin_email AS SELECT .`

## 6. Persistent Rules and the `+` Prefix

### 6.1 Design Principles

Clear separation of concerns:

| Syntax | Purpose | DD Materialization | Type Checking |
|--------|---------|-------------------|---------------|
| `type` | Value type definitions | No | N/A |
| `+name(col: type, ...)` | Schema declaration | **No** | **Yes** |
| `+name(...) <- body` | Persistent rule (DD view) | **Yes** | Only if schema exists |
| `name(...) <- body` | Session rule (transient) | **No** | Only if schema exists |
| `+`/`-` (facts) | Base data manipulation | No | Only if schema exists |

### 6.2 Persistent Rule Grammar

```ebnf
PersistentRule ::= "+" RuleName "(" ParamList ")" "<-" Body "."
```

### 6.3 Session Rules

Rules without `+` prefix are **session rules**:

```datalog
temp_result(X, Y) <- source(X, Y), X > 10
```

- Computed on-demand during evaluation
- NOT persisted or incrementally maintained
- Useful for ad-hoc queries

## 7. Implementation Notes

### 7.1 Type Persistence

All typing information needs to be persisted on a database level. The server implements multiple databases where same-named types could have different semantic meanings.

### 7.2 Naming Conventions

To avoid confusion between types and variables:

- **Types**: `UIdent` (capitalized) - `Email`, `User`, `Purchase`
- **Variables**: `LIdent` or `UIdent` - `e`, `Email`, `user_id`
- **Relations**: `LIdent` (lowercase) - `user`, `purchase`, `admin_email`

### 7.3 Command vs Keyword Distinction

Do NOT confuse:
- `+name(col: type)` - Schema declaration syntax
- `.rel` meta command - REPL command to list/describe relations

## 8. Complete Example

```datalog
// Type definitions
type Id: int(range(1, 1000000))
type Email: string(pattern("^[^@]+@[^@]+$"))

// Schema declarations
+user(id: Id, name: string, email: Email)
+purchase(user_id: Id, amount: int)

// Base data
+user[(1, "Alice", "alice@example.com"), (2, "Bob", "bob@example.com")]
+purchase[(1, 1500), (1, 200), (2, 300)]

// Persistent rule (explicit DD materialization)
+high_spender(UserId) <-
    purchase(UserId, Amount),
    Amount > 1000

// Session rule (not materialized, just computed on query)
temp(Id) <- user(Id, _, _), high_spender(Id)

// Query
?high_spender(X)
```

## 9. Type Checking Algorithm

### 9.1 Schema Lookup

Given a rule:

```datalog
+admin_email(Email) <- user(_, _, Email), admin(Email)
```

Type checking steps:
1. Lookup schema: if `+admin_email(email: Email)` exists, check arity matches
2. Check that variable types are consistent across the rule
3. Report type errors if mismatches found

### 9.2 Variable Type Inference

Variables get their types from:
1. Their position in atoms with declared schemas
2. Comparison with constants
3. Aggregation context5:["$","$Le",null,{"page":{"title":"Type System Specification","content":"$f","toc":[{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"1. Type Declarations (type)","id":"1-type-declarations-type"},{"level":3,"text":"1.1 Grammar","id":"11-grammar"},{"level":3,"text":"1.2 Semantics","id":"12-semantics"},{"level":3,"text":"1.3 Aliases and Refinements","id":"13-aliases-and-refinements"},{"level":3,"text":"1.4 Record Types","id":"14-record-types"},{"level":2,"text":"2. Schema Declarations","id":"2-schema-declarations"},{"level":3,"text":"2.1 Grammar","id":"21-grammar"},{"level":3,"text":"2.2 Schema Declaration","id":"22-schema-declaration"},{"level":3,"text":"2.3 Schema with Type References","id":"23-schema-with-type-references"},{"level":2,"text":"3. Terms and Expressions","id":"3-terms-and-expressions"},{"level":3,"text":"3.1 Grammar","id":"31-grammar"},{"level":2,"text":"4. Atoms, Facts, and Rules","id":"4-atoms-facts-and-rules"},{"level":3,"text":"4.1 Atoms","id":"41-atoms"},{"level":3,"text":"4.2 Facts","id":"42-facts"},{"level":3,"text":"4.3 Rules","id":"43-rules"},{"level":3,"text":"4.4 Persistent vs Session Rules","id":"44-persistent-vs-session-rules"},{"level":2,"text":"5. Base vs Derived Relations","id":"5-base-vs-derived-relations"},{"level":2,"text":"6. Persistent Rules and the + Prefix","id":"6-persistent-rules-and-the-prefix"},{"level":3,"text":"6.1 Design Principles","id":"61-design-principles"},{"level":3,"text":"6.2 Persistent Rule Grammar","id":"62-persistent-rule-grammar"},{"level":3,"text":"6.3 Session Rules","id":"63-session-rules"},{"level":2,"text":"7. Implementation Notes","id":"7-implementation-notes"},{"level":3,"text":"7.1 Type Persistence","id":"71-type-persistence"},{"level":3,"text":"7.2 Naming Conventions","id":"72-naming-conventions"},{"level":3,"text":"7.3 Command vs Keyword Distinction","id":"73-command-vs-keyword-distinction"},{"level":2,"text":"8. Complete Example","id":"8-complete-example"},{"level":2,"text":"9. Type Checking Algorithm","id":"9-type-checking-algorithm"},{"level":3,"text":"9.1 Schema Lookup","id":"91-schema-lookup"},{"level":3,"text":"9.2 Variable Type Inference","id":"92-variable-type-inference"}]},"slugKey":"internals/type-system"}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
10:I[6869,[],"IconMark"]
c:[["$","title","0",{"children":"InputLayer - A symbolic reasoning engine for AI agents"}],["$","meta","1",{"name":"description","content":"Store facts, define rules, and derive everything that logically follows. Vector search, graph traversal, and incremental computation in one system."}],["$","link","2",{"rel":"icon","href":"/icon.svg"}],["$","$L10","3",{}]]
8:null
