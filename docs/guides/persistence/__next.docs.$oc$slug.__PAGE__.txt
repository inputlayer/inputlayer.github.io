1:"$Sreact.fragment"
2:I[8428,["758","static/chunks/758-3cb69ce377cde046.js","121","static/chunks/121-aece4f809b101dc1.js","502","static/chunks/502-e809071f8789437b.js","689","static/chunks/689-4fcf9680fdc90283.js","870","static/chunks/app/docs/%5B%5B...slug%5D%5D/page-004ec69e3c86920a.js"],"DocsPageClient"]
5:I[484,[],"OutletBoundary"]
6:"$Sreact.suspense"
3:T2064,# Persistence Guide

InputLayer provides durable storage with crash recovery, using a combination of Write-Ahead Logging (WAL) and Parquet batch files.

## Architecture Overview

```
Insert/Delete
    ↓
Update{data, time, diff}
    ↓
WAL (immediate durability)
    ↓
In-memory buffer
    ↓ (when buffer full)
Batch file (Parquet)
```

### Recovery Flow

On startup, InputLayer:
1. Loads shard metadata from disk
2. Reads batch files (Parquet)
3. Replays WAL (uncommitted updates)
4. Consolidates to get current state

---

## Directory Structure

```
data/
├── persist/
│   ├── shards/           # Shard metadata (JSON)
│   │   ├── default_edge.json
│   │   └── default_node.json
│   ├── batches/          # Data files (Parquet)
│   │   ├── 1.parquet
│   │   └── 2.parquet
│   └── wal/              # Write-ahead log
│       └── current.wal
```

---

## Durability Modes

InputLayer offers three durability modes, configurable via `config.toml`:

### Immediate Mode (Default)

Every write syncs to disk before returning:

```toml
[storage.persist]
durability_mode = "immediate"
```

| Property | Value |
|----------|-------|
| Write Latency | Highest |
| Crash Safety | Full (zero data loss) |
| Use Case | Financial data, critical records |

### Batched Mode

Writes buffer in memory with periodic sync:

```toml
[storage.persist]
durability_mode = "batched"
buffer_size = 10000
```

| Property | Value |
|----------|-------|
| Write Latency | Medium |
| Crash Safety | Partial (may lose last batch) |
| Use Case | Most production workloads |

### Async Mode

Writes return immediately; background persistence:

```toml
[storage.persist]
durability_mode = "async"
```

| Property | Value |
|----------|-------|
| Write Latency | Lowest |
| Crash Safety | Minimal (may lose recent updates) |
| Use Case | Analytics pipelines, high-throughput ingestion |

---

## Write-Ahead Log (WAL)

The WAL provides O(1) append-only persistence with immediate durability.

### WAL Entry Format

Each entry is a checksummed JSON line (format: `<crc32hex>:<json>`):

```json
{"shard":"default:edge","update":{"data":[1,2],"time":1,"diff":1}}
{"shard":"default:edge","update":{"data":[1,2],"time":2,"diff":-1}}
```

### WAL Entry Fields

| Field | Description |
|-------|-------------|
| `shard` | Shard name in `"kg:relation"` format |
| `update.data` | The tuple data |
| `update.time` | Logical timestamp (monotonically increasing) |
| `update.diff` | Multiplicity change: `+1` for insert, `-1` for delete |

Each line is prefixed with a CRC32 checksum for integrity verification during recovery.

### Automatic Compaction

WAL entries are compacted to Parquet when:
- Buffer reaches configured size (`buffer_size`)
- Manual flush is triggered
- Server shutdown (clean)

After compaction, the WAL is archived and cleared.

---

## Batch Files (Parquet)

Data is stored in columnar Parquet format for efficient queries.

### Parquet Schema

Each batch file contains:
- **Data columns**: Your tuple fields
- **time**: Update timestamp (UInt64)
- **diff**: +1 for insert, -1 for delete (Int64)

### Compression

Snappy compression is used by default (fast decompression, good ratio).

### Example File

```
batches/1.parquet
├── col0: Int32 [1, 3, 5]
├── col1: Int32 [2, 4, 6]
├── time: UInt64 [10, 20, 30]
└── diff: Int64 [1, 1, 1]
```

---

## Shards

Each relation is stored as a separate "shard" with its own:
- Metadata file (JSON)
- Batch files (Parquet)
- WAL entries

### Shard Metadata

```json
{
  "name": "default:edge",
  "since": 0,
  "upper": 100,
  "batches": [
    {
      "id": "1",
      "path": "batches/1.parquet",
      "lower": 0,
      "upper": 50,
      "len": 100
    }
  ]
}
```

| Field | Description |
|-------|-------------|
| `name` | Shard identifier (kg:relation) |
| `since` | Lower bound frontier (history discarded before this) |
| `upper` | Upper bound frontier (latest update time + 1) |
| `batches` | List of batch file references |

---

## Compaction

Compaction consolidates history and reclaims space.

### Manual Compaction

```datalog
.compact
```

This:
1. Flushes all pending writes
2. Merges batch files
3. Removes historical entries before `since` frontier
4. Clears WAL

### Automatic Compaction

Compaction is triggered automatically when a shard accumulates more than `auto_compact_threshold` batch files (default: 10). The check runs every `auto_compact_interval_secs` seconds (default: 300).

```toml
[storage.persist]
auto_compact_threshold = 10      # Compact after this many batch files
auto_compact_interval_secs = 300  # Check interval (seconds)
```

---

## Configuration Reference

```toml
[storage]
# Base directory for all data
data_dir = "./data"

[storage.persist]
# Enable DD-native persistence
enabled = true

# Buffer size before flushing to Parquet
buffer_size = 10000

# Durability: immediate, batched, async
durability_mode = "immediate"

# Auto-compact when this many batch files accumulate (0 = disabled)
auto_compact_threshold = 10

# Check interval for auto-compaction in seconds (0 = disabled)
auto_compact_interval_secs = 300
```

---

## Best Practices

### Development

```toml
[storage.persist]
durability_mode = "async"
buffer_size = 1000
```

Fast iteration, acceptable data loss on crashes.

### Production

```toml
[storage.persist]
durability_mode = "immediate"
buffer_size = 10000
```

Maximum safety, reasonable performance.

### High-Throughput Ingestion

```toml
[storage.persist]
durability_mode = "batched"
buffer_size = 100000

[storage.performance]
batch_size = 10000
async_io = true
```

Balance between throughput and safety.

### Memory-Constrained

```toml
[storage.persist]
buffer_size = 1000
auto_compact_threshold = 5

[storage.performance]
initial_capacity = 1000
batch_size = 100
```

Frequent flushes, aggressive compaction.

---

## Monitoring

### Check Storage Status

```bash
.status
```

Shows:
- Data directory location
- Number of shards
- WAL size
- Buffer status

### Check Shard Info

```datalog
.rel
```

Lists all relations with row counts.

---

## Recovery Scenarios

### Normal Startup

1. Load shard metadata
2. Read Parquet batch files
3. Replay WAL entries
4. Consolidate to current state

### Crash Recovery

Same as normal startup. WAL ensures all committed writes are recovered.

### Corrupted Parquet

If a batch file is corrupted:
1. WAL entries for that batch may still be available
2. Manually remove corrupted `.parquet` file
3. Restart to trigger WAL replay

### Corrupted WAL

If WAL is corrupted:
1. Data in Parquet files is safe
2. Uncommitted writes since last flush are lost
3. Rename/remove corrupted WAL file
4. Restart

---

## Differential Updates

InputLayer uses differential dataflow semantics internally:

```rust
Update {
    data: Tuple,    // The actual data
    time: u64,      // Logical timestamp
    diff: i64,      // +1 = insert, -1 = delete
}
```

### Consolidation

Multiple updates to the same tuple are consolidated:

| Updates | Consolidated |
|---------|-------------|
| +1, +1 | +2 (duplicate insert) |
| +1, -1 | 0 (cancelled out) |
| +1, -1, +1 | +1 (net insert) |

This enables:
- Efficient delta storage
- Time-travel queries (if history preserved)
- Incremental computation

---

## Troubleshooting

### High Write Latency

**Cause**: Immediate durability mode with slow disk

**Solutions**:
1. Switch to `batched` durability mode
2. Use faster storage (SSD)
3. Increase `buffer_size` to batch more writes

### High Memory Usage

**Cause**: Large buffer, many shards

**Solutions**:
1. Reduce `buffer_size`
2. Lower `auto_compact_threshold` for more frequent compaction
3. Flush more frequently

### Slow Startup

**Cause**: Large WAL, many batch files

**Solutions**:
1. Run `.compact` before shutdown
2. Enable compaction window
3. Flush buffers before shutdown

### Missing Data After Crash

**Cause**: Async durability mode

**Solutions**:
1. Switch to `immediate` or `batched` mode
2. Accept trade-off for async mode

---

## Next Steps

- [Configuration Guide](configuration) - Full configuration reference
- [REST API Guide](rest-api) - Programmatic access
- [Temporal Functions](temporal) - Time-based queries on persisted data0:{"buildId":"05bjYGyiAumoEMBrfWHih","rsc":["$","$1","c",{"children":[["$","$L2",null,{"page":{"title":"Persistence Guide","content":"$3","toc":[{"level":2,"text":"Architecture Overview","id":"architecture-overview"},{"level":3,"text":"Recovery Flow","id":"recovery-flow"},{"level":2,"text":"Directory Structure","id":"directory-structure"},{"level":2,"text":"Durability Modes","id":"durability-modes"},{"level":3,"text":"Immediate Mode (Default)","id":"immediate-mode-default"},{"level":3,"text":"Batched Mode","id":"batched-mode"},{"level":3,"text":"Async Mode","id":"async-mode"},{"level":2,"text":"Write-Ahead Log (WAL)","id":"write-ahead-log-wal"},{"level":3,"text":"WAL Entry Format","id":"wal-entry-format"},{"level":3,"text":"WAL Entry Fields","id":"wal-entry-fields"},{"level":3,"text":"Automatic Compaction","id":"automatic-compaction"},{"level":2,"text":"Batch Files (Parquet)","id":"batch-files-parquet"},{"level":3,"text":"Parquet Schema","id":"parquet-schema"},{"level":3,"text":"Compression","id":"compression"},{"level":3,"text":"Example File","id":"example-file"},{"level":2,"text":"Shards","id":"shards"},{"level":3,"text":"Shard Metadata","id":"shard-metadata"},{"level":2,"text":"Compaction","id":"compaction"},{"level":3,"text":"Manual Compaction","id":"manual-compaction"},{"level":3,"text":"Automatic Compaction","id":"automatic-compaction"},{"level":2,"text":"Configuration Reference","id":"configuration-reference"},{"level":2,"text":"Best Practices","id":"best-practices"},{"level":3,"text":"Development","id":"development"},{"level":3,"text":"Production","id":"production"},{"level":3,"text":"High-Throughput Ingestion","id":"high-throughput-ingestion"},{"level":3,"text":"Memory-Constrained","id":"memory-constrained"},{"level":2,"text":"Monitoring","id":"monitoring"},{"level":3,"text":"Check Storage Status","id":"check-storage-status"},{"level":3,"text":"Check Shard Info","id":"check-shard-info"},{"level":2,"text":"Recovery Scenarios","id":"recovery-scenarios"},{"level":3,"text":"Normal Startup","id":"normal-startup"},{"level":3,"text":"Crash Recovery","id":"crash-recovery"},{"level":3,"text":"Corrupted Parquet","id":"corrupted-parquet"},{"level":3,"text":"Corrupted WAL","id":"corrupted-wal"},{"level":2,"text":"Differential Updates","id":"differential-updates"},{"level":3,"text":"Consolidation","id":"consolidation"},{"level":2,"text":"Troubleshooting","id":"troubleshooting"},{"level":3,"text":"High Write Latency","id":"high-write-latency"},{"level":3,"text":"High Memory Usage","id":"high-memory-usage"},{"level":3,"text":"Slow Startup","id":"slow-startup"},{"level":3,"text":"Missing Data After Crash","id":"missing-data-after-crash"},{"level":2,"text":"Next Steps","id":"next-steps"}]},"slugKey":"guides/persistence"}],null,"$L4"]}],"loading":null,"isPartial":false}
4:["$","$L5",null,{"children":["$","$6",null,{"name":"Next.MetadataOutlet","children":"$@7"}]}]
7:null
