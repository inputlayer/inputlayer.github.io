1:"$Sreact.fragment"
2:I[1942,["177","static/chunks/app/layout-7e9963bf811be36b.js"],"ThemeProvider"]
3:I[7121,[],""]
4:I[4581,[],""]
6:I[484,[],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[484,[],"ViewportBoundary"]
b:I[484,[],"MetadataBoundary"]
d:I[7123,[],""]
:HL["/_next/static/media/4cf2300e9c8272f7-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/4bd7a24b7976d4e6.css","style"]
0:{"P":null,"b":"05bjYGyiAumoEMBrfWHih","c":["","docs","guides","core-concepts",""],"q":"","i":false,"f":[[["",{"children":["docs",{"children":[["slug","guides/core-concepts","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4bd7a24b7976d4e6.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__variable_188709 __variable_9a8899 font-sans antialiased","children":["$","$L2",null,{"attribute":"class","defaultTheme":"dark","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:I[8428,["758","static/chunks/758-3cb69ce377cde046.js","121","static/chunks/121-aece4f809b101dc1.js","502","static/chunks/502-e809071f8789437b.js","689","static/chunks/689-4fcf9680fdc90283.js","870","static/chunks/app/docs/%5B%5B...slug%5D%5D/page-004ec69e3c86920a.js"],"DocsPageClient"]
f:T15a3,# Data Modeling Guide

Identity semantics, schema options, and update patterns.

## Identity Model

InputLayer uses **pure multiset semantics** by default, where the **entire tuple is the identity**. This is the native model for Differential Dataflow (DD).

### Default Behavior (No Schema)

Without an explicit schema, tuples are identified by all their values:

```datalog
+person("alice", 30)     // Insert tuple ("alice", 30)
+person("alice", 31)     // Insert different tuple ("alice", 31)
```

Both tuples coexist because they are different values. There is no concept of "alice" as an entity with a mutable "age" attribute.

### Implications

| Aspect | Behavior |
|--------|----------|
| Tuple identity | ALL columns (entire tuple) |
| Duplicate handling | Multiset - same tuple can exist multiple times |
| Updates | Must know all column values to delete |

## Schema Declarations

Schemas define the structure and constraints for relations.

### Basic Schema

Declare a schema using typed arguments:

```datalog
+person(id: int, name: string, age: int)
```

## Update Patterns

### Pattern 1: Exact Delete (Know All Values)

When you know the exact tuple to delete:

```datalog
-person("alice", 30)
+person("alice", 31)
```

### Pattern 2: Conditional Delete (Unknown Values)

When you don't know all column values, use a conditional delete:

```datalog
// Delete alice regardless of age
-person("alice", Age) <- person("alice", Age)
+person("alice", 31)
```

### Pattern 3: Atomic Update

Combine delete and insert in one atomic operation:

```datalog
-person(Name, OldAge), +person(Name, NewAge) <-
  person(Name, OldAge),
  Name = "alice",
  NewAge = OldAge + 1
```

This executes at the same logical timestamp, ensuring atomicity.

## Deletion Patterns

### Delete Specific Tuple

```datalog
-edge(1, 2)
```

### Delete All Matching Tuples

```datalog
// Delete all edges from node 5
-edge(5, Y) <- edge(5, Y)

// Delete all high earners
-employee(Name, Dept, Salary) <-
  employee(Name, Dept, Salary),
  Salary > 100000
```

### Delete a Rule

To delete a persistent rule:

```datalog
-reachable
```

This drops the rule named `reachable`. To delete all facts from a relation, use a conditional delete:

```datalog
-person(X, Y, Z) <- person(X, Y, Z)  // Delete all tuples
```

To drop a relation entirely (schema + data), use the meta command:

```datalog
.rel drop person
```

## Schema Inference

When no schema is declared, it's inferred from the first insert:

```datalog
+person("alice", 30)          // Inferred: person(string, int)
+person("bob", 25)            // OK: matches inferred schema
+person("charlie", "young")   // ERROR: type mismatch (string vs int)
```

## Transient vs Persistent

### Persistent Schema (`+` prefix)

Stored in the database catalog:

```datalog
+person(id: int, name: string, age: int)
```

### Transient Schema (no prefix)

Session-only, cleared on database switch:

```datalog
temp(x: int, y: int)
temp(1, 2)
temp(3, 4)
// Cleared when switching databases
```

Use transient schemas for:
- REPL exploration with type safety
- Temporary working data
- Testing schema designs before persisting

## Rules (Views)

### Rule Identity

A **view** (derived relation) is identified by its **head predicate name**. A view contains one or more rules:

```datalog
+reachable(X, Y) <- edge(X, Y)                   // Creates view, adds rule 1
+reachable(X, Y) <- reachable(X, Z), edge(Z, Y)  // Adds rule 2 to same view
```

### Deleting Views

Delete an entire view with:

```datalog
-reachable
```

Individual rule clauses can be removed using `.rule remove`:

```datalog
.rule remove reachable 1   // Remove first clause of 'reachable' rule
.rule drop reachable       // Remove entire 'reachable' rule (all clauses)
```

Or use file-based workflow:

```datalog
.rule clear reachable
.load views/reachable.idl
```

### Session Rules

Rules without `+` are transient:

```datalog
temp(X, Y) <- edge(X, Y), X < Y
```

Session rules:
- Are not persisted
- Are cleared on database switch
- Support recursion (full fixed-point iteration)

## File-Based Workflow

For complex views with many rules, use `.idl` script files:

```datalog
// views/reachable.idl
+reachable(X, Y) <- edge(X, Y)
+reachable(X, Y) <- reachable(X, Z), edge(Z, Y)
```

### Example Workflow

```datalog
// Initial load
.load views/access_control.idl

// After modifying the file, clear rules first then reload
.rule clear access_control
.load views/access_control.idl
```

## Best Practices

### 1. Use Explicit Schemas

Explicit schemas catch type errors early:

```datalog
+employee(id: int, name: string, salary: float)
```

### 2. Use Conditional Deletes for Unknown Values

```datalog
// Update all employees in a department
-employee(Id, OldDept, Name), +employee(Id, "Engineering", Name) <-
  employee(Id, OldDept, Name),
  OldDept = "Legacy"
```

### 3. Use File-Based Workflow for Complex Rules

Keep rule definitions in version-controlled files:

```
views/
  access_control.idl
  graph_analysis.idl
  reporting.idl
```

### 4. Use Persistent Rules for Automatic Materialization

Persistent rules are automatically materialized and updated when base data changes:

```datalog
// Session rules compute fresh each query:
reachable(X, Y) <- edge(X, Y)
reachable(X, Y) <- reachable(X, Z), edge(Z, Y)

// Persistent rules materialize and cache results:
+reachable(X, Y) <- edge(X, Y)
+reachable(X, Y) <- reachable(X, Z), edge(Z, Y)
```

Both session and persistent rules support full recursion with fixed-point iteration.5:["$","$Le",null,{"page":{"title":"Data Modeling Guide","content":"$f","toc":[{"level":2,"text":"Identity Model","id":"identity-model"},{"level":3,"text":"Default Behavior (No Schema)","id":"default-behavior-no-schema"},{"level":3,"text":"Implications","id":"implications"},{"level":2,"text":"Schema Declarations","id":"schema-declarations"},{"level":3,"text":"Basic Schema","id":"basic-schema"},{"level":2,"text":"Update Patterns","id":"update-patterns"},{"level":3,"text":"Pattern 1: Exact Delete (Know All Values)","id":"pattern-1-exact-delete-know-all-values"},{"level":3,"text":"Pattern 2: Conditional Delete (Unknown Values)","id":"pattern-2-conditional-delete-unknown-values"},{"level":3,"text":"Pattern 3: Atomic Update","id":"pattern-3-atomic-update"},{"level":2,"text":"Deletion Patterns","id":"deletion-patterns"},{"level":3,"text":"Delete Specific Tuple","id":"delete-specific-tuple"},{"level":3,"text":"Delete All Matching Tuples","id":"delete-all-matching-tuples"},{"level":3,"text":"Delete a Rule","id":"delete-a-rule"},{"level":2,"text":"Schema Inference","id":"schema-inference"},{"level":2,"text":"Transient vs Persistent","id":"transient-vs-persistent"},{"level":3,"text":"Persistent Schema (+ prefix)","id":"persistent-schema-prefix"},{"level":3,"text":"Transient Schema (no prefix)","id":"transient-schema-no-prefix"},{"level":2,"text":"Rules (Views)","id":"rules-views"},{"level":3,"text":"Rule Identity","id":"rule-identity"},{"level":3,"text":"Deleting Views","id":"deleting-views"},{"level":3,"text":"Session Rules","id":"session-rules"},{"level":2,"text":"File-Based Workflow","id":"file-based-workflow"},{"level":3,"text":"Example Workflow","id":"example-workflow"},{"level":2,"text":"Best Practices","id":"best-practices"},{"level":3,"text":"1. Use Explicit Schemas","id":"1-use-explicit-schemas"},{"level":3,"text":"2. Use Conditional Deletes for Unknown Values","id":"2-use-conditional-deletes-for-unknown-values"},{"level":3,"text":"3. Use File-Based Workflow for Complex Rules","id":"3-use-file-based-workflow-for-complex-rules"},{"level":3,"text":"4. Use Persistent Rules for Automatic Materialization","id":"4-use-persistent-rules-for-automatic-materialization"}]},"slugKey":"guides/core-concepts"}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
10:I[6869,[],"IconMark"]
c:[["$","title","0",{"children":"InputLayer - A symbolic reasoning engine for AI agents"}],["$","meta","1",{"name":"description","content":"Store facts, define rules, and derive everything that logically follows. Vector search, graph traversal, and incremental computation in one system."}],["$","link","2",{"rel":"icon","href":"/icon.svg"}],["$","$L10","3",{}]]
8:null
