1:"$Sreact.fragment"
2:I[1942,["177","static/chunks/app/layout-7e9963bf811be36b.js"],"ThemeProvider"]
3:I[7121,[],""]
4:I[4581,[],""]
6:I[484,[],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[484,[],"ViewportBoundary"]
b:I[484,[],"MetadataBoundary"]
d:I[7123,[],""]
:HL["/_next/static/media/4cf2300e9c8272f7-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/4bd7a24b7976d4e6.css","style"]
0:{"P":null,"b":"05bjYGyiAumoEMBrfWHih","c":["","docs","reference","syntax",""],"q":"","i":false,"f":[[["",{"children":["docs",{"children":[["slug","reference/syntax","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4bd7a24b7976d4e6.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__variable_188709 __variable_9a8899 font-sans antialiased","children":["$","$L2",null,{"attribute":"class","defaultTheme":"dark","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:I[8428,["758","static/chunks/758-3cb69ce377cde046.js","121","static/chunks/121-aece4f809b101dc1.js","502","static/chunks/502-e809071f8789437b.js","689","static/chunks/689-4fcf9680fdc90283.js","870","static/chunks/app/docs/%5B%5B...slug%5D%5D/page-004ec69e3c86920a.js"],"DocsPageClient"]
f:T2ee9,# Syntax Reference

Complete syntax reference for InputLayer's query language.

## Grammar Overview

```
program     ::= statement*
statement   ::= fact | rule | query | meta_command | schema_decl

fact        ::= '+' atom
              | '+' relation '[' tuple_list ']'
              | '-' atom

rule        ::= '+' atom '<-' body           // Persistent rule
              | atom '<-' body               // Session rule

query       ::= '?' body

body        ::= goal (',' goal)*
goal        ::= atom | constraint | negated_atom

atom        ::= relation '(' term_list ')'
negated_atom::= '!' atom

term        ::= variable | constant | expression
term_list   ::= term (',' term)*

constraint  ::= term op term
op          ::= '=' | '!=' | '<' | '<=' | '>' | '>='
```

## Lexical Elements

### Identifiers

| Type | Pattern | Examples |
|------|---------|----------|
| Relation | `[a-z][a-z0-9_]*` | `edge`, `my_relation`, `path2` |
| Variable | `[A-Z][a-zA-Z0-9_]*` | `X`, `Name`, `PersonId` |
| Placeholder | `_` | Matches any value, discarded |

### Literals

#### Integers
```datalog
42        // Decimal
-17       // Negative
0         // Zero
```

#### Floats
```datalog
3.14      // Decimal float
-0.5      // Negative float
1.0e10    // Scientific notation
```

#### Strings
```datalog
"hello"           // Basic string
"hello world"     // With spaces
"line1\nline2"    // Escape sequences
"say \"hi\""      // Escaped quotes
```

**Escape sequences:**
| Sequence | Meaning |
|----------|---------|
| `\n` | Newline |
| `\t` | Tab |
| `\\` | Backslash |
| `\"` | Quote |

#### Vectors
```datalog
[1.0, 2.0, 3.0]           // Float vector
[0.1, 0.2, 0.3, 0.4]      // Embedding
```

### Comments

```datalog
// Single line comment

/* Multi-line
   block comment */

+edge(1, 2)  // Inline comment
```

## Statements

### Fact Insertion (`+`)

Insert base data into relations.

**Single fact:**
```datalog
+edge(1, 2)
+person("alice", 30)
+location("NYC", 40.7, -74.0)
```

**Bulk insert:**
```datalog
+edge[(1, 2), (2, 3), (3, 4), (4, 5)]
+person[("alice", 30), ("bob", 25), ("carol", 35)]
```

### Fact Deletion (`-`)

Remove base data from relations.

**Single fact:**
```datalog
-edge(1, 2)
```

**Conditional delete (based on another relation):**
```datalog
// Delete all edges where source node is in the 'banned' relation
-edge(X, Y) <- banned(X)

// Delete all edges where X is greater than 5
-edge(X, Y) <- edge(X, Y), X > 5

// Delete edges that form triangles
-edge(X, Y) <- edge(X, Y), edge(Y, Z), edge(Z, X)
```

**Note:** Conditional delete finds all tuples matching the condition and removes them from the target relation. The target relation is automatically included in the query body to bind all head variables.

### Persistent Rules (`+head <- body`)

Define derived relations that persist across sessions.

```datalog
// Simple derivation
+adult(Name, Age) <- person(Name, Age), Age >= 18

// Join
+works_in(Name, Building) <-
  employee(Name, Dept),
  department(Dept, Building)

// Recursive
+path(X, Y) <- edge(X, Y)
+path(X, Z) <- path(X, Y), edge(Y, Z)

// With negation
+orphan(X) <- person(X), !parent(_, X)

// With aggregation
+dept_size(Dept, count<Emp>) <- employee(Emp, Dept)
```

### Session Rules (no `+` prefix)

Transient rules that exist only for the current session.

```datalog
// Not persisted
temp(X, Y) <- edge(X, Y), X < Y
debug(X) <- some_complex_condition(X)
```

### Queries (`?`)

Ask questions about the data.

```datalog
// Simple query
? edge(X, Y)

// With constants
? edge(1, X)

// With constraints
? person(Name, Age), Age > 25

// Join query
? person(Id, Name, _, _), purchase(Id, Item, _)
```

### Schema Declarations

Define typed schemas for relations.

```datalog
// Basic schema
+employee(id: int, name: string, dept: string)

// All types
+example(
  a: int,
  b: float,
  c: string,
  d: vector
)
```

**Supported types:**
| Type | Description | Example Values |
|------|-------------|----------------|
| `int` | 64-bit integer | `42`, `-17`, `0` |
| `float` | 64-bit float | `3.14`, `-0.5` |
| `string` | UTF-8 string | `"hello"`, `"world"` |
| `bool` | Boolean | `true`, `false` |
| `timestamp` | Unix timestamp (ms) | Aliases: `time`, `datetime` |
| `vector` | Float array | `[0.1, 0.2, 0.3]` |

## Expressions

### Arithmetic

```datalog
+computed(X, Y) <- input(A, B), X = A + B, Y = A * B
```

| Operator | Description |
|----------|-------------|
| `+` | Addition |
| `-` | Subtraction |
| `*` | Multiplication |
| `/` | Division |
| `%` | Modulo |

### Comparison

```datalog
? person(Name, Age), Age >= 18, Age < 65
```

| Operator | Description |
|----------|-------------|
| `=` | Equal |
| `!=` | Not equal |
| `<` | Less than |
| `<=` | Less or equal |
| `>` | Greater than |
| `>=` | Greater or equal |

### Built-in Functions

**Vector functions:**

InputLayer provides built-in vector distance and similarity functions:

```datalog
// Compute cosine similarity between embeddings
? embedding(Id1, V1), embedding(Id2, V2), Id1 < Id2,
   Sim = cosine(V1, V2), Sim > 0.9

// Compute Euclidean distance between points
? point(Id1, V1), point(Id2, V2), Id1 < Id2,
   Dist = euclidean(V1, V2), Dist < 1.0
```

| Function | Description |
|----------|-------------|
| `euclidean(v1, v2)` | Euclidean distance |
| `cosine(v1, v2)` | Cosine similarity |
| `dot(v1, v2)` | Dot product |
| `manhattan(v1, v2)` | Manhattan distance |

Vector functions work in both query bodies and rule heads (via computed head variables). See [functions](functions) for the complete list (55 functions including vector, temporal, math, string, LSH, and quantization).

## Aggregations

Compute aggregate values over groups.

### Syntax

```datalog
+result(GroupBy1, GroupBy2, agg<AggColumn>) <-
  source(GroupBy1, GroupBy2, AggColumn, _)
```

Variables in the head that are not aggregated become group-by columns.

### Aggregate Functions

| Function | Description | Example |
|----------|-------------|---------|
| `count<X>` | Count rows | `count<Id>` |
| `sum<X>` | Sum values | `sum<Amount>` |
| `min<X>` | Minimum | `min<Age>` |
| `max<X>` | Maximum | `max<Score>` |
| `avg<X>` | Average | `avg<Salary>` |

### Examples

```datalog
// Count per group
+city_count(City, count<Id>) <- person(Id, _, _, City)

// Sum
+total_sales(Product, sum<Amount>) <- sale(_, Product, Amount)

// Multiple aggregates (separate rules)
+stats_min(min<Age>) <- person(_, _, Age, _)
+stats_max(max<Age>) <- person(_, _, Age, _)

// Global aggregate (no group-by)
+total(sum<Amount>) <- purchase(_, _, Amount)
```

## Negation

Express "does not exist" conditions.

### Syntax

```datalog
!atom(args)     // Negated atom
```

### Rules

1. **Safety**: Variables in negation must appear positively elsewhere
2. **Stratification**: No circular dependencies through negation

### Examples

```datalog
// People without purchases
+non_buyer(Id, Name) <-
  person(Id, Name, _, _),
  !purchase(Id, _, _)

// Nodes with no outgoing edges
+sink(X) <- node(X), !edge(X, _)

// Set difference
+only_in_a(X) <- a(X), !b(X)
```

### Invalid (Unsafe)

```datalog
// WRONG - X only appears in negation
+bad(X) <- !some_rel(X)

// CORRECT - X appears positively
+good(X) <- domain(X), !some_rel(X)
```

## Meta Commands

Commands that control the REPL environment.

### Knowledge Graph Commands

```datalog
.kg                     // Show current knowledge graph
.kg list                // List all knowledge graphs
.kg create <name>       // Create knowledge graph
.kg use <name>          // Switch to knowledge graph
.kg drop <name>         // Delete knowledge graph
```

### Relation Commands

```datalog
.rel                    // List relations with data
.rel <name>             // Show schema and sample data
.rel drop <name>        // Drop a relation and its data
```

### Rule Commands

```datalog
.rule                   // List all rules
.rule <name>            // Query a rule
.rule def <name>        // Show rule definition
.rule drop <name>       // Delete all clauses of a rule
.rule remove <name> <n> // Remove clause #n (1-based)
.rule clear <name>      // Clear for re-registration
.rule edit <name> <n> <clause>  // Edit clause
```

### Session Commands

```datalog
.session                // List session rules
.session clear          // Clear all session rules
.session drop <n>       // Remove session rule #n
```

### File Commands

```datalog
.load <file>            // Execute a .idl file
```

### Index Commands

```datalog
.index                  // List all indexes
.index list             // List all indexes (explicit)
.index create <name> on <relation>(<column>) [options]
.index drop <name>      // Drop an index
.index stats <name>     // Show index statistics
.index rebuild <name>   // Rebuild an index
```

### User & Auth Commands

```datalog
.user list              // List all users
.user create <name> <password> <role>  // Create user
.user drop <name>       // Delete user
.user password <name> <password>       // Change password
.user role <name> <role>               // Change role
.apikey create <label>  // Create API key
.apikey list            // List API keys
.apikey revoke <label>  // Revoke API key
.kg acl list [<kg>]     // List ACLs
.kg acl grant <kg> <user> <role>  // Grant access
.kg acl revoke <kg> <user>        // Revoke access
```

### System Commands

```datalog
.status                 // System status
.compact                // Compact storage
.explain <query>        // Show query plan
.help                   // Help message
.quit                   // Exit REPL
.exit                   // Exit REPL (alias)
```

## Recursion

### Basic Pattern

```datalog
// Base case
+derived(X, Y) <- base(X, Y)

// Recursive case
+derived(X, Z) <- derived(X, Y), base(Y, Z)
```

### Transitive Closure

```datalog
+reachable(X, Y) <- edge(X, Y)
+reachable(X, Z) <- reachable(X, Y), edge(Y, Z)
```

### Mutual Recursion

```datalog
+odd(X) <- edge(Start, X), start(Start)
+odd(X) <- even(Y), edge(Y, X)
+even(X) <- odd(Y), edge(Y, X)
```

### Restrictions

- Negation through recursion is not allowed (non-stratifiable)
- Must have a base case that terminates

## Complete Examples

### Social Network

```datalog
// Schema
+person(id: int, name: string, age: int)
+follows(follower: int, followed: int)

// Data
+person[(1, "alice", 30), (2, "bob", 25), (3, "carol", 35)]
+follows[(1, 2), (2, 3), (1, 3)]

// Rules
+mutual_follow(A, B) <-
  follows(A, B),
  follows(B, A),
  A < B

+influencer(Id, count<Follower>) <-
  follows(Follower, Id)

// Query
? influencer(Id, Count), Count > 10
```

### Graph Analysis

```datalog
// Transitive closure
+path(X, Y) <- edge(X, Y)
+path(X, Z) <- path(X, Y), edge(Y, Z)

// Cycle detection
+in_cycle(X) <- path(X, X)

// Connected components (undirected)
+bidir(X, Y) <- edge(X, Y)
+bidir(X, Y) <- edge(Y, X)
+connected(X, Y) <- bidir(X, Y)
+connected(X, Z) <- connected(X, Y), bidir(Y, Z)

// Sink nodes (no outgoing)
+sink(X) <- node(X), !edge(X, _)

// Source nodes (no incoming)
+source(X) <- node(X), !edge(_, X)
```

### Bill of Materials

```datalog
// Part hierarchy
+contains(assembly: int, part: int, qty: int)

// All parts needed (recursive)
+requires(Asm, Part) <- contains(Asm, Part, _)
+requires(Asm, Part) <-
  contains(Asm, Sub, _),
  requires(Sub, Part)

// Total quantity calculation
+total_qty(Asm, Part, sum<Qty>) <-
  contains(Asm, Part, Qty)
```

## Reserved Words

The following are reserved and cannot be used as relation names:

```
true, false
count, sum, min, max, avg
int, float, string, vector
```

## File Format

InputLayer files use the `.idl` extension and contain valid InputLayer statements:

```datalog
// my_program.idl

// Schema declarations
+node(id: int, label: string)
+edge(src: int, dst: int, weight: float)

// Data
+node[(1, "a"), (2, "b"), (3, "c")]
+edge[(1, 2, 1.0), (2, 3, 2.0)]

// Rules
+path(X, Y, W) <- edge(X, Y, W)
+path(X, Z, W) <- path(X, Y, W1), edge(Y, Z, W2), W = W1 + W2
```

Load with:
```datalog
.load my_program.idl
```5:["$","$Le",null,{"page":{"title":"Syntax Reference","content":"$f","toc":[{"level":2,"text":"Grammar Overview","id":"grammar-overview"},{"level":2,"text":"Lexical Elements","id":"lexical-elements"},{"level":3,"text":"Identifiers","id":"identifiers"},{"level":3,"text":"Literals","id":"literals"},{"level":3,"text":"Comments","id":"comments"},{"level":2,"text":"Statements","id":"statements"},{"level":3,"text":"Fact Insertion (+)","id":"fact-insertion-"},{"level":3,"text":"Fact Deletion (-)","id":"fact-deletion-"},{"level":3,"text":"Persistent Rules (+head <- body)","id":"persistent-rules-head-body"},{"level":3,"text":"Session Rules (no + prefix)","id":"session-rules-no-prefix"},{"level":3,"text":"Queries (?)","id":"queries-"},{"level":3,"text":"Schema Declarations","id":"schema-declarations"},{"level":2,"text":"Expressions","id":"expressions"},{"level":3,"text":"Arithmetic","id":"arithmetic"},{"level":3,"text":"Comparison","id":"comparison"},{"level":3,"text":"Built-in Functions","id":"built-in-functions"},{"level":2,"text":"Aggregations","id":"aggregations"},{"level":3,"text":"Syntax","id":"syntax"},{"level":3,"text":"Aggregate Functions","id":"aggregate-functions"},{"level":3,"text":"Examples","id":"examples"},{"level":2,"text":"Negation","id":"negation"},{"level":3,"text":"Syntax","id":"syntax"},{"level":3,"text":"Rules","id":"rules"},{"level":3,"text":"Examples","id":"examples"},{"level":3,"text":"Invalid (Unsafe)","id":"invalid-unsafe"},{"level":2,"text":"Meta Commands","id":"meta-commands"},{"level":3,"text":"Knowledge Graph Commands","id":"knowledge-graph-commands"},{"level":3,"text":"Relation Commands","id":"relation-commands"},{"level":3,"text":"Rule Commands","id":"rule-commands"},{"level":3,"text":"Session Commands","id":"session-commands"},{"level":3,"text":"File Commands","id":"file-commands"},{"level":3,"text":"Index Commands","id":"index-commands"},{"level":3,"text":"User & Auth Commands","id":"user-auth-commands"},{"level":3,"text":"System Commands","id":"system-commands"},{"level":2,"text":"Recursion","id":"recursion"},{"level":3,"text":"Basic Pattern","id":"basic-pattern"},{"level":3,"text":"Transitive Closure","id":"transitive-closure"},{"level":3,"text":"Mutual Recursion","id":"mutual-recursion"},{"level":3,"text":"Restrictions","id":"restrictions"},{"level":2,"text":"Complete Examples","id":"complete-examples"},{"level":3,"text":"Social Network","id":"social-network"},{"level":3,"text":"Graph Analysis","id":"graph-analysis"},{"level":3,"text":"Bill of Materials","id":"bill-of-materials"},{"level":2,"text":"Reserved Words","id":"reserved-words"},{"level":2,"text":"File Format","id":"file-format"}]},"slugKey":"reference/syntax"}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
10:I[6869,[],"IconMark"]
c:[["$","title","0",{"children":"InputLayer - A symbolic reasoning engine for AI agents"}],["$","meta","1",{"name":"description","content":"Store facts, define rules, and derive everything that logically follows. Vector search, graph traversal, and incremental computation in one system."}],["$","link","2",{"rel":"icon","href":"/icon.svg"}],["$","$L10","3",{}]]
8:null
