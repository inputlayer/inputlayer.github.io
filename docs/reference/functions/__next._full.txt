1:"$Sreact.fragment"
2:I[1942,["177","static/chunks/app/layout-7e9963bf811be36b.js"],"ThemeProvider"]
3:I[7121,[],""]
4:I[4581,[],""]
6:I[484,[],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[484,[],"ViewportBoundary"]
b:I[484,[],"MetadataBoundary"]
d:I[7123,[],""]
:HL["/_next/static/media/4cf2300e9c8272f7-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/4bd7a24b7976d4e6.css","style"]
0:{"P":null,"b":"05bjYGyiAumoEMBrfWHih","c":["","docs","reference","functions",""],"q":"","i":false,"f":[[["",{"children":["docs",{"children":[["slug","reference/functions","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4bd7a24b7976d4e6.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__variable_188709 __variable_9a8899 font-sans antialiased","children":["$","$L2",null,{"attribute":"class","defaultTheme":"dark","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$@a"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$@c"}]}]}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:I[8428,["758","static/chunks/758-3cb69ce377cde046.js","121","static/chunks/121-aece4f809b101dc1.js","502","static/chunks/502-e809071f8789437b.js","689","static/chunks/689-4fcf9680fdc90283.js","870","static/chunks/app/docs/%5B%5B...slug%5D%5D/page-004ec69e3c86920a.js"],"DocsPageClient"]
f:T5db0,# InputLayer Builtin Functions Reference

---

## Overview

InputLayer provides 55 builtin functions for vector operations, temporal processing, quantization, string manipulation, and math utilities.

---

## Table of Contents

1. [Distance Functions](#1-distance-functions)
2. [Vector Operations](#2-vector-operations)
3. [LSH Functions](#3-lsh-locality-sensitive-hashing-functions)
4. [Quantization Functions](#4-quantization-functions)
5. [Int8 Distance Functions](#5-int8-distance-functions)
6. [Temporal Functions](#6-temporal-functions)
7. [Math Functions](#7-math-functions)
8. [String Functions](#8-string-functions)
9. [Scalar Min/Max Functions](#9-scalar-minmax-functions)

---

## 1. Distance Functions

Distance functions for f32 vectors. All return `Float64`.

### euclidean(v1, v2)

Euclidean (L2) distance between two vectors.

```datalog
// Syntax
D = euclidean(V1, V2)

// Example
similar(Id1, Id2, Dist) <-
    vectors(Id1, V1),
    vectors(Id2, V2),
    Id1 < Id2,
    Dist = euclidean(V1, V2),
    Dist < 1.0
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | Vector (f32) | First vector |
| v2 | Vector (f32) | Second vector |
| **Returns** | Float64 | Euclidean distance (>= 0) |

---

### cosine(v1, v2)

Cosine distance (1 - cosine similarity) between two vectors.

```datalog
// Syntax
D = cosine(V1, V2)

// Example - Find similar documents
similar_docs(Id1, Id2) <-
    doc_embedding(Id1, V1),
    doc_embedding(Id2, V2),
    D = cosine(V1, V2),
    D < 0.1  // Very similar (close to 0)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | Vector (f32) | First vector |
| v2 | Vector (f32) | Second vector |
| **Returns** | Float64 | Cosine distance (range [0, 2]) |

**Note**: Returns 0 for identical directions, 1 for orthogonal, 2 for opposite directions.

---

### dot(v1, v2)

Dot product of two vectors.

```datalog
// Syntax
Score = dot(V1, V2)

// Example - Compute relevance scores
relevance(QueryId, DocId, Score) <-
    query_vector(QueryId, Q),
    doc_vector(DocId, D),
    Score = dot(Q, D)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | Vector (f32) | First vector |
| v2 | Vector (f32) | Second vector |
| **Returns** | Float64 | Dot product |

---

### manhattan(v1, v2)

Manhattan (L1) distance between two vectors. Good for sparse vectors.

```datalog
// Syntax
D = manhattan(V1, V2)

// Example
nearby(Id1, Id2) <-
    location(Id1, V1),
    location(Id2, V2),
    D = manhattan(V1, V2),
    D < 10.0
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | Vector (f32) | First vector |
| v2 | Vector (f32) | Second vector |
| **Returns** | Float64 | Manhattan distance (>= 0) |

---

## 2. Vector Operations

Operations for manipulating vectors.

### normalize(v)

Normalize vector to unit length.

```datalog
// Syntax
Normalized = normalize(V)

// Example - Normalize before cosine similarity
normalized_embedding(Id, NormV) <-
    raw_embedding(Id, V),
    NormV = normalize(V)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Input vector |
| **Returns** | Vector (f32) | Unit vector (length = 1) |

**Note**: Returns zero vector if input is zero vector.

---

### vec_dim(v)

Get the dimension (length) of a float32 vector.

```datalog
// Syntax
Dim = vec_dim(V)

// Example - Filter by dimension
valid_embedding(Id, V) <-
    embedding(Id, V),
    Dim = vec_dim(V),
    Dim = 128
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Input vector |
| **Returns** | Int64 | Number of dimensions |

---

### vec_add(v1, v2)

Element-wise addition of two vectors.

```datalog
// Syntax
Sum = vec_add(V1, V2)

// Example - Combine embeddings
combined(Id, SumV) <-
    text_embedding(Id, T),
    image_embedding(Id, I),
    SumV = vec_add(T, I)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | Vector (f32) | First vector |
| v2 | Vector (f32) | Second vector |
| **Returns** | Vector (f32) | Element-wise sum |

**Note**: Vectors must have same dimension.

---

### vec_scale(v, scalar)

Scale vector by a scalar value.

```datalog
// Syntax
Scaled = vec_scale(V, S)

// Example - Apply weight
weighted(Id, ScaledV) <-
    embedding(Id, V),
    weight(Id, W),
    ScaledV = vec_scale(V, W)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Input vector |
| scalar | Float64 | Scale factor |
| **Returns** | Vector (f32) | Scaled vector |

---

## 3. LSH (Locality Sensitive Hashing) Functions

Functions for approximate nearest neighbor search.

### lsh_bucket(v, table_idx, num_hyperplanes)

Compute LSH bucket ID for a float32 vector.

```datalog
// Syntax
Bucket = lsh_bucket(V, TableIdx, NumHyperplanes)

// Example - Build LSH index
lsh_index(Id, Table, Bucket) <-
    embedding(Id, V),
    Table = 0,
    Bucket = lsh_bucket(V, Table, 8)  // 8 hyperplanes = 256 buckets
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Input vector |
| table_idx | Int64 | Hash table index (for multiple tables) |
| num_hyperplanes | Int64 | Number of hyperplanes (controls granularity) |
| **Returns** | Int64 | Bucket ID |

**Note**: More hyperplanes = more buckets = higher precision but lower recall.

---

### lsh_probes(bucket, num_hp, num_probes)

Generate multi-probe sequence for a bucket by Hamming distance.

```datalog
// Syntax
Probes = lsh_probes(Bucket, NumHyperplanes, NumProbes)

// Example - Get probe sequence
probe_buckets(OrigBucket, Probes) <-
    query_bucket(OrigBucket),
    Probes = lsh_probes(OrigBucket, 8, 4)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| bucket | Int64 | Original bucket ID |
| num_hp | Int64 | Number of hyperplanes used |
| num_probes | Int64 | Number of probe buckets to generate |
| **Returns** | Vector | Probe bucket IDs |

---

### lsh_multi_probe(v, table_idx, num_hp, num_probes)

Compute LSH bucket and probes in one call for float32 vectors.

```datalog
// Syntax
Buckets = lsh_multi_probe(V, TableIdx, NumHyperplanes, NumProbes)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Query vector |
| table_idx | Int64 | Hash table index |
| num_hp | Int64 | Number of hyperplanes |
| num_probes | Int64 | Number of probes |
| **Returns** | Vector | Bucket IDs to probe |

---

## 4. Quantization Functions

Functions for int8 vector quantization (memory-efficient storage).

### quantize_linear(v)

Linear quantization: maps [min, max] to [-128, 127].

```datalog
// Syntax
QV = quantize_linear(V)

// Example - Compress embeddings
compressed(Id, QV) <-
    embedding(Id, V),
    QV = quantize_linear(V)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Input vector |
| **Returns** | VectorInt8 | Quantized vector |

---

### quantize_symmetric(v)

Symmetric quantization: maps [-max_abs, max_abs] to [-127, 127], preserving zero.

```datalog
QV = quantize_symmetric(V)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | Vector (f32) | Input vector |
| **Returns** | VectorInt8 | Quantized vector |

**Note**: Better preserves zero values; recommended for normalized vectors.

---

### dequantize(v)

Convert int8 vector back to f32.

```datalog
FV = dequantize(QV)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | VectorInt8 | Quantized vector |
| **Returns** | Vector (f32) | Dequantized vector |

**Note**: Lossy conversion - original precision not fully recovered.

---

### dequantize_scaled(v, scale)

Dequantize with explicit scale factor.

```datalog
FV = dequantize_scaled(QV, Scale)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v | VectorInt8 | Quantized vector |
| scale | Float64 | Scale factor |
| **Returns** | Vector (f32) | Dequantized vector |

---

## 5. Int8 Distance Functions

### Native (Fast) Int8 Distance

Direct computation on int8 values for maximum speed.

### euclidean_int8(v1, v2)

Euclidean distance for int8 vectors.

```datalog
D = euclidean_int8(QV1, QV2)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | VectorInt8 | First quantized vector |
| v2 | VectorInt8 | Second quantized vector |
| **Returns** | Float64 | Euclidean distance |

---

### cosine_int8(v1, v2)

Cosine distance for int8 vectors.

```datalog
D = cosine_int8(QV1, QV2)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | VectorInt8 | First quantized vector |
| v2 | VectorInt8 | Second quantized vector |
| **Returns** | Float64 | Cosine distance [0, 2] |

---

### dot_int8(v1, v2)

Dot product for int8 vectors.

```datalog
Score = dot_int8(QV1, QV2)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | VectorInt8 | First quantized vector |
| v2 | VectorInt8 | Second quantized vector |
| **Returns** | Float64 | Dot product |

---

### manhattan_int8(v1, v2)

Manhattan distance for int8 vectors.

```datalog
D = manhattan_int8(QV1, QV2)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| v1 | VectorInt8 | First quantized vector |
| v2 | VectorInt8 | Second quantized vector |
| **Returns** | Float64 | Manhattan distance |

---

## 6. Temporal Functions

Functions for time-based queries and temporal reasoning.

### time_now()

Get current Unix timestamp in milliseconds.

```datalog
Now = time_now()
```

| Parameter | Type | Description |
|-----------|------|-------------|
| (none) | - | No parameters |
| **Returns** | Int64 | Unix timestamp (milliseconds) |

---

### time_diff(t1, t2)

Compute difference between two timestamps.

```datalog
Diff = time_diff(T1, T2)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| t1 | Int64 | First timestamp |
| t2 | Int64 | Second timestamp |
| **Returns** | Int64 | Difference (t1 - t2) in milliseconds |

---

### time_add(ts, duration_ms)

Add duration to timestamp.

```datalog
NewTime = time_add(Ts, DurationMs)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Base timestamp |
| duration_ms | Int64 | Duration to add (milliseconds) |
| **Returns** | Int64 | New timestamp |

---

### time_sub(ts, duration_ms)

Subtract duration from timestamp.

```datalog
NewTime = time_sub(Ts, DurationMs)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Base timestamp |
| duration_ms | Int64 | Duration to subtract (milliseconds) |
| **Returns** | Int64 | New timestamp |

---

### time_decay(ts, now, half_life_ms)

Exponential time decay. Formula: `0.5^(age/half_life)`.

```datalog
Weight = time_decay(Ts, Now, HalfLifeMs)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Event timestamp |
| now | Int64 | Current timestamp |
| half_life_ms | Int64 | Half-life in milliseconds |
| **Returns** | Float64 | Decay factor [0, 1] |

**Note**: Returns 1.0 at ts=now, 0.5 at age=half_life, approaches 0 for old events.

---

### time_decay_linear(ts, now, max_age_ms)

Linear time decay. Formula: `max(0, 1 - age/max_age)`.

```datalog
Weight = time_decay_linear(Ts, Now, MaxAgeMs)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Event timestamp |
| now | Int64 | Current timestamp |
| max_age_ms | Int64 | Maximum age for decay |
| **Returns** | Float64 | Decay factor [0, 1] |

**Note**: Returns 1.0 at ts=now, 0.5 at age=max_age/2, 0.0 at age>=max_age.

---

### time_before(t1, t2)

Check if t1 is before t2.

| Parameter | Type | Description |
|-----------|------|-------------|
| t1 | Int64 | First timestamp |
| t2 | Int64 | Second timestamp |
| **Returns** | Bool | true if t1 < t2 |

---

### time_after(t1, t2)

Check if t1 is after t2.

| Parameter | Type | Description |
|-----------|------|-------------|
| t1 | Int64 | First timestamp |
| t2 | Int64 | Second timestamp |
| **Returns** | Bool | true if t1 > t2 |

---

### time_between(ts, start, end)

Check if timestamp is within range [start, end] (inclusive).

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Timestamp to check |
| start | Int64 | Window start |
| end | Int64 | Window end |
| **Returns** | Bool | true if start <= ts <= end |

---

### within_last(ts, now, duration_ms)

Check if timestamp is within the last duration from now.

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Timestamp to check |
| now | Int64 | Current timestamp |
| duration_ms | Int64 | Window size in milliseconds |
| **Returns** | Bool | true if (now - duration_ms) <= ts <= now |

---

### intervals_overlap(s1, e1, s2, e2)

Check if two time intervals overlap.

| Parameter | Type | Description |
|-----------|------|-------------|
| s1 | Int64 | First interval start |
| e1 | Int64 | First interval end |
| s2 | Int64 | Second interval start |
| e2 | Int64 | Second interval end |
| **Returns** | Bool | true if intervals overlap |

---

### interval_contains(s1, e1, s2, e2)

Check if interval [s1, e1] fully contains interval [s2, e2].

| Parameter | Type | Description |
|-----------|------|-------------|
| s1 | Int64 | Outer interval start |
| e1 | Int64 | Outer interval end |
| s2 | Int64 | Inner interval start |
| e2 | Int64 | Inner interval end |
| **Returns** | Bool | true if [s1,e1] contains [s2,e2] |

---

### interval_duration(start, end)

Get the duration of an interval.

| Parameter | Type | Description |
|-----------|------|-------------|
| start | Int64 | Interval start |
| end | Int64 | Interval end |
| **Returns** | Int64 | Duration (end - start) in milliseconds |

---

### point_in_interval(ts, start, end)

Check if a point is within an interval [start, end] (inclusive).

| Parameter | Type | Description |
|-----------|------|-------------|
| ts | Int64 | Point timestamp |
| start | Int64 | Interval start |
| end | Int64 | Interval end |
| **Returns** | Bool | true if start <= ts <= end |

---

## 7. Math Functions

General-purpose math functions. All accept Int64 or Float64 inputs (coerced to f64 internally unless noted).

### abs(x)

Generic absolute value. Preserves input type.

```datalog
A = abs(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Int64 or Float64 | Input value |
| **Returns** | Same as input | Absolute value |

---

### abs_int64(x)

Absolute value of an integer.

```datalog
AbsVal = abs_int64(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Int64 | Input integer |
| **Returns** | Int64 | Absolute value |

**Note**: Uses saturating arithmetic for `i64::MIN`.

---

### abs_float64(x)

Absolute value of a float.

```datalog
AbsVal = abs_float64(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 | Input float |
| **Returns** | Float64 | Absolute value |

---

### sqrt(x)

Square root.

```datalog
R = sqrt(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Input value (>= 0) |
| **Returns** | Float64 | Square root |

**Note**: Returns Null if x < 0.

---

### pow(base, exp)

Power function.

```datalog
R = pow(Base, Exp)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| base | Float64 or Int64 | Base value |
| exp | Float64 or Int64 | Exponent |
| **Returns** | Float64 | base^exp |

---

### log(x)

Natural logarithm (base e).

```datalog
R = log(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Input value (> 0) |
| **Returns** | Float64 | Natural logarithm |

**Note**: Returns Null if x <= 0.

---

### exp(x)

Exponential function (e^x).

```datalog
R = exp(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Input value |
| **Returns** | Float64 | e^x |

---

### sin(x)

Sine function (radians).

```datalog
R = sin(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Angle in radians |
| **Returns** | Float64 | Sine of x |

---

### cos(x)

Cosine function (radians).

```datalog
R = cos(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Angle in radians |
| **Returns** | Float64 | Cosine of x |

---

### tan(x)

Tangent function (radians).

```datalog
R = tan(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Angle in radians |
| **Returns** | Float64 | Tangent of x |

---

### floor(x)

Round down to nearest integer.

```datalog
R = floor(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Input value |
| **Returns** | Int64 | Largest integer <= x |

---

### ceil(x)

Round up to nearest integer.

```datalog
R = ceil(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Input value |
| **Returns** | Int64 | Smallest integer >= x |

---

### sign(x)

Sign function. Returns -1, 0, or 1.

```datalog
S = sign(X)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| x | Float64 or Int64 | Input value |
| **Returns** | Int64 | -1 (negative), 0 (zero), or 1 (positive) |

**Note**: For float NaN, returns 0.

---

## 8. String Functions

Functions for string manipulation.

### len(s)

Get string length (byte count).

```datalog
L = len(S)

// Example
long_names(Name, L) <-
    names(Name),
    L = len(Name),
    L > 10
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s | String | Input string |
| **Returns** | Int64 | Byte length of string |

---

### upper(s)

Convert string to uppercase (Unicode-aware).

```datalog
U = upper(S)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s | String | Input string |
| **Returns** | String | Uppercase string |

---

### lower(s)

Convert string to lowercase (Unicode-aware).

```datalog
L = lower(S)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s | String | Input string |
| **Returns** | String | Lowercase string |

---

### trim(s)

Remove leading and trailing whitespace.

```datalog
T = trim(S)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s | String | Input string |
| **Returns** | String | Trimmed string |

---

### substr(s, start, len)

Extract a substring.

```datalog
Sub = substr(S, Start, Len)

// Example - Get first 3 characters
prefix(Name, P) <-
    names(Name),
    P = substr(Name, 0, 3)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s | String | Input string |
| start | Int64 | Start byte index (0-based) |
| len | Int64 | Maximum length to extract |
| **Returns** | String | Extracted substring |

**Note**: Returns empty string if start > string length. Clamps to string bounds.

---

### replace(s, find, replacement)

Replace all occurrences of a substring.

```datalog
R = replace(S, Find, Replacement)

// Example
cleaned(R) <-
    raw("hello-world"),
    R = replace("hello-world", "-", " ")
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s | String | Input string |
| find | String | Substring to find |
| replacement | String | Replacement string |
| **Returns** | String | String with all occurrences replaced |

---

### concat(s1, s2, ...)

Concatenate multiple values into a string. Variable arity (2+ arguments).

```datalog
R = concat(S1, S2)

// Example - Build full name
full_name(First, Last, Full) <-
    person(First, Last),
    Full = concat(First, " ", Last)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| s1, s2, ... | String/Int64/Float64 | Values to concatenate |
| **Returns** | String | Concatenated string |

**Note**: Non-string values are automatically converted to their string representation.

---

## 9. Scalar Min/Max Functions

Scalar comparison functions returning the minimum or maximum of two values.

### min_val(a, b)

Return the smaller of two values.

```datalog
M = min_val(A, B)

// Example - Clamp to range
clamped(X, C) <-
    values(X),
    C = max_val(0, min_val(X, 100))
```

| Parameter | Type | Description |
|-----------|------|-------------|
| a | Int64/Float64/String | First value |
| b | Int64/Float64/String | Second value |
| **Returns** | Same as input | Smaller of the two values |

**Note**: Do not confuse with the `min` aggregation. `min_val` is a scalar function comparing two values. Mixed numeric types (Int64 + Float64) return Float64. Strings compare lexicographically.

---

### max_val(a, b)

Return the larger of two values.

```datalog
M = max_val(A, B)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| a | Int64/Float64/String | First value |
| b | Int64/Float64/String | Second value |
| **Returns** | Same as input | Larger of the two values |

**Note**: Do not confuse with the `max` aggregation. `max_val` is a scalar function comparing two values. Mixed numeric types (Int64 + Float64) return Float64. Strings compare lexicographically.

---

## Appendix: Function Quick Reference

| Function | Parameters | Returns | Category |
|----------|-----------|---------|----------|
| `euclidean` | (v1, v2) | Float64 | Distance |
| `cosine` | (v1, v2) | Float64 | Distance |
| `dot` | (v1, v2) | Float64 | Distance |
| `manhattan` | (v1, v2) | Float64 | Distance |
| `normalize` | (v) | Vector | Vector Ops |
| `vec_dim` | (v) | Int64 | Vector Ops |
| `vec_add` | (v1, v2) | Vector | Vector Ops |
| `vec_scale` | (v, s) | Vector | Vector Ops |
| `lsh_bucket` | (v, table, hp) | Int64 | LSH |
| `lsh_probes` | (bucket, hp, n) | Vector | LSH |
| `lsh_multi_probe` | (v, table, hp, n) | Vector | LSH |
| `quantize_linear` | (v) | VectorInt8 | Quantization |
| `quantize_symmetric` | (v) | VectorInt8 | Quantization |
| `dequantize` | (qv) | Vector | Quantization |
| `dequantize_scaled` | (qv, s) | Vector | Quantization |
| `euclidean_int8` | (qv1, qv2) | Float64 | Int8 Distance |
| `cosine_int8` | (qv1, qv2) | Float64 | Int8 Distance |
| `dot_int8` | (qv1, qv2) | Float64 | Int8 Distance |
| `manhattan_int8` | (qv1, qv2) | Float64 | Int8 Distance |
| `time_now` | () | Int64 | Temporal |
| `time_diff` | (t1, t2) | Int64 | Temporal |
| `time_add` | (ts, dur) | Int64 | Temporal |
| `time_sub` | (ts, dur) | Int64 | Temporal |
| `time_decay` | (ts, now, hl) | Float64 | Temporal |
| `time_decay_linear` | (ts, now, max) | Float64 | Temporal |
| `time_before` | (t1, t2) | Bool | Temporal |
| `time_after` | (t1, t2) | Bool | Temporal |
| `time_between` | (ts, s, e) | Bool | Temporal |
| `within_last` | (ts, now, dur) | Bool | Temporal |
| `intervals_overlap` | (s1, e1, s2, e2) | Bool | Temporal |
| `interval_contains` | (s1, e1, s2, e2) | Bool | Temporal |
| `interval_duration` | (s, e) | Int64 | Temporal |
| `point_in_interval` | (ts, s, e) | Bool | Temporal |
| `abs` | (x) | same type | Math |
| `abs_int64` | (x) | Int64 | Math |
| `abs_float64` | (x) | Float64 | Math |
| `sqrt` | (x) | Float64 | Math |
| `pow` | (base, exp) | Float64 | Math |
| `log` | (x) | Float64 | Math |
| `exp` | (x) | Float64 | Math |
| `sin` | (x) | Float64 | Math |
| `cos` | (x) | Float64 | Math |
| `tan` | (x) | Float64 | Math |
| `floor` | (x) | Int64 | Math |
| `ceil` | (x) | Int64 | Math |
| `sign` | (x) | Int64 | Math |
| `len` | (s) | Int64 | String |
| `upper` | (s) | String | String |
| `lower` | (s) | String | String |
| `trim` | (s) | String | String |
| `substr` | (s, start, len) | String | String |
| `replace` | (s, find, repl) | String | String |
| `concat` | (s1, s2, ...) | String | String |
| `min_val` | (a, b) | same type | Min/Max |
| `max_val` | (a, b) | same type | Min/Max |5:["$","$Le",null,{"page":{"title":"InputLayer Builtin Functions Reference","content":"$f","toc":[{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Table of Contents","id":"table-of-contents"},{"level":2,"text":"1. Distance Functions","id":"1-distance-functions"},{"level":3,"text":"euclidean(v1, v2)","id":"euclideanv1-v2"},{"level":3,"text":"cosine(v1, v2)","id":"cosinev1-v2"},{"level":3,"text":"dot(v1, v2)","id":"dotv1-v2"},{"level":3,"text":"manhattan(v1, v2)","id":"manhattanv1-v2"},{"level":2,"text":"2. Vector Operations","id":"2-vector-operations"},{"level":3,"text":"normalize(v)","id":"normalizev"},{"level":3,"text":"vecdim(v)","id":"vecdimv"},{"level":3,"text":"vecadd(v1, v2)","id":"vecaddv1-v2"},{"level":3,"text":"vecscale(v, scalar)","id":"vecscalev-scalar"},{"level":2,"text":"3. LSH (Locality Sensitive Hashing) Functions","id":"3-lsh-locality-sensitive-hashing-functions"},{"level":3,"text":"lshbucket(v, tableidx, numhyperplanes)","id":"lshbucketv-tableidx-numhyperplanes"},{"level":3,"text":"lshprobes(bucket, numhp, numprobes)","id":"lshprobesbucket-numhp-numprobes"},{"level":3,"text":"lshmultiprobe(v, tableidx, numhp, numprobes)","id":"lshmultiprobev-tableidx-numhp-numprobes"},{"level":2,"text":"4. Quantization Functions","id":"4-quantization-functions"},{"level":3,"text":"quantizelinear(v)","id":"quantizelinearv"},{"level":3,"text":"quantizesymmetric(v)","id":"quantizesymmetricv"},{"level":3,"text":"dequantize(v)","id":"dequantizev"},{"level":3,"text":"dequantizescaled(v, scale)","id":"dequantizescaledv-scale"},{"level":2,"text":"5. Int8 Distance Functions","id":"5-int8-distance-functions"},{"level":3,"text":"Native (Fast) Int8 Distance","id":"native-fast-int8-distance"},{"level":3,"text":"euclideanint8(v1, v2)","id":"euclideanint8v1-v2"},{"level":3,"text":"cosineint8(v1, v2)","id":"cosineint8v1-v2"},{"level":3,"text":"dotint8(v1, v2)","id":"dotint8v1-v2"},{"level":3,"text":"manhattanint8(v1, v2)","id":"manhattanint8v1-v2"},{"level":2,"text":"6. Temporal Functions","id":"6-temporal-functions"},{"level":3,"text":"timenow()","id":"timenow"},{"level":3,"text":"timediff(t1, t2)","id":"timedifft1-t2"},{"level":3,"text":"timeadd(ts, durationms)","id":"timeaddts-durationms"},{"level":3,"text":"timesub(ts, durationms)","id":"timesubts-durationms"},{"level":3,"text":"timedecay(ts, now, halflifems)","id":"timedecayts-now-halflifems"},{"level":3,"text":"timedecaylinear(ts, now, maxagems)","id":"timedecaylinearts-now-maxagems"},{"level":3,"text":"timebefore(t1, t2)","id":"timebeforet1-t2"},{"level":3,"text":"timeafter(t1, t2)","id":"timeaftert1-t2"},{"level":3,"text":"timebetween(ts, start, end)","id":"timebetweents-start-end"},{"level":3,"text":"withinlast(ts, now, durationms)","id":"withinlastts-now-durationms"},{"level":3,"text":"intervalsoverlap(s1, e1, s2, e2)","id":"intervalsoverlaps1-e1-s2-e2"},{"level":3,"text":"intervalcontains(s1, e1, s2, e2)","id":"intervalcontainss1-e1-s2-e2"},{"level":3,"text":"intervalduration(start, end)","id":"intervaldurationstart-end"},{"level":3,"text":"pointininterval(ts, start, end)","id":"pointinintervalts-start-end"},{"level":2,"text":"7. Math Functions","id":"7-math-functions"},{"level":3,"text":"abs(x)","id":"absx"},{"level":3,"text":"absint64(x)","id":"absint64x"},{"level":3,"text":"absfloat64(x)","id":"absfloat64x"},{"level":3,"text":"sqrt(x)","id":"sqrtx"},{"level":3,"text":"pow(base, exp)","id":"powbase-exp"},{"level":3,"text":"log(x)","id":"logx"},{"level":3,"text":"exp(x)","id":"expx"},{"level":3,"text":"sin(x)","id":"sinx"},{"level":3,"text":"cos(x)","id":"cosx"},{"level":3,"text":"tan(x)","id":"tanx"},{"level":3,"text":"floor(x)","id":"floorx"},{"level":3,"text":"ceil(x)","id":"ceilx"},{"level":3,"text":"sign(x)","id":"signx"},{"level":2,"text":"8. String Functions","id":"8-string-functions"},{"level":3,"text":"len(s)","id":"lens"},{"level":3,"text":"upper(s)","id":"uppers"},{"level":3,"text":"lower(s)","id":"lowers"},{"level":3,"text":"trim(s)","id":"trims"},{"level":3,"text":"substr(s, start, len)","id":"substrs-start-len"},{"level":3,"text":"replace(s, find, replacement)","id":"replaces-find-replacement"},{"level":3,"text":"concat(s1, s2, ...)","id":"concats1-s2-"},{"level":2,"text":"9. Scalar Min/Max Functions","id":"9-scalar-minmax-functions"},{"level":3,"text":"minval(a, b)","id":"minvala-b"},{"level":3,"text":"maxval(a, b)","id":"maxvala-b"},{"level":2,"text":"Appendix: Function Quick Reference","id":"appendix-function-quick-reference"}]},"slugKey":"reference/functions"}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
10:I[6869,[],"IconMark"]
c:[["$","title","0",{"children":"InputLayer - A symbolic reasoning engine for AI agents"}],["$","meta","1",{"name":"description","content":"Store facts, define rules, and derive everything that logically follows. Vector search, graph traversal, and incremental computation in one system."}],["$","link","2",{"rel":"icon","href":"/icon.svg"}],["$","$L10","3",{}]]
8:null
