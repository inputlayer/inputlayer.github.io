<!DOCTYPE html><!--05bjYGyiAumoEMBrfWHih--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/4bd7a24b7976d4e6.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-bd6546b43ab2ecbf.js"/><script src="/_next/static/chunks/4bd1b696-deba172d32c79f82.js" async=""></script><script src="/_next/static/chunks/794-275dc9ebd3a29fbf.js" async=""></script><script src="/_next/static/chunks/main-app-1fa5b694e5d36a75.js" async=""></script><script src="/_next/static/chunks/app/layout-7e9963bf811be36b.js" async=""></script><script src="/_next/static/chunks/758-3cb69ce377cde046.js" async=""></script><script src="/_next/static/chunks/121-aece4f809b101dc1.js" async=""></script><script src="/_next/static/chunks/830-dbae36b1030f3d7c.js" async=""></script><script src="/_next/static/chunks/689-4fcf9680fdc90283.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-a68506d98e2282cb.js" async=""></script><meta name="next-size-adjust" content=""/><title>InputLayer - A symbolic reasoning engine for AI agents</title><meta name="description" content="Store facts, define rules, and derive everything that logically follows. Vector search, graph traversal, and incremental computation in one system."/><link rel="icon" href="/icon.svg"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_188709 __variable_9a8899 font-sans antialiased"><div hidden=""><!--$--><!--/$--></div><script>((a,b,c,d,e,f,g,h)=>{let i=document.documentElement,j=["light","dark"];function k(b){var c;(Array.isArray(a)?a:[a]).forEach(a=>{let c="class"===a,d=c&&f?e.map(a=>f[a]||a):e;c?(i.classList.remove(...d),i.classList.add(f&&f[b]?f[b]:b)):i.setAttribute(a,b)}),c=b,h&&j.includes(c)&&(i.style.colorScheme=c)}if(d)k(d);else try{let a=localStorage.getItem(b)||c,d=g&&"system"===a?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":a;k(d)}catch(a){}})("class","theme","dark",null,["light","dark"],null,true,true)</script><div class="flex flex-col min-h-dvh"><header class="sticky top-0 z-50 w-full border-b border-border/50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60"><div class="flex h-14 items-center px-6"><a class="mr-8" href="/"><span class="inline-flex items-center gap-1.5"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="flex-shrink-0"><path d="M12 2L2 7l10 5 10-5-10-5z"></path><path d="M2 17l10 5 10-5"></path><path d="M2 12l10 5 10-5"></path></svg><span class="font-extrabold tracking-tight text-lg">InputLayer</span></span></a><nav class="hidden md:flex items-center gap-6 text-sm"><a class="text-muted-foreground transition-colors hover:text-foreground" href="/docs/">Docs</a><a class="text-muted-foreground transition-colors hover:text-foreground" href="/blog/">Blog</a><a class="text-muted-foreground transition-colors hover:text-foreground" href="/use-cases/">Use Cases</a><a class="text-muted-foreground transition-colors hover:text-foreground" href="/compare/">Compare</a><a href="https://demo.inputlayer.ai" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-muted-foreground transition-colors hover:text-foreground">Demo<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3 w-3"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></nav><div class="ml-auto flex items-center gap-3"><div class="inline-flex items-center gap-1.5"><a href="https://github.com/inputlayer/inputlayer" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1.5 rounded-md border border-border bg-secondary/50 px-2.5 py-1 text-xs font-medium text-muted-foreground transition-colors hover:text-foreground hover:bg-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star h-3.5 w-3.5"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"></path></svg><span>Star</span></a><a href="https://github.com/inputlayer/inputlayer/fork" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1.5 rounded-md border border-border bg-secondary/50 px-2.5 py-1 text-xs font-medium text-muted-foreground transition-colors hover:text-foreground hover:bg-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-git-fork h-3.5 w-3.5"><circle cx="12" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><circle cx="18" cy="6" r="3"></circle><path d="M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9"></path><path d="M12 12v3"></path></svg><span>Fork</span></a></div><button data-slot="button" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-9 h-9 w-9"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun h-4 w-4"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg></button><div class="md:hidden"><button class="inline-flex items-center justify-center rounded-md p-2 text-muted-foreground hover:text-foreground hover:bg-secondary transition-colors" aria-label="Open menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu h-5 w-5"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></div></div></header><main class="flex-1"><section class="border-b border-border/50"><div class="relative overflow-hidden"><div class="absolute inset-0 bg-gradient-to-b from-primary/5 to-transparent"></div><div class="relative mx-auto max-w-6xl px-6 py-16 lg:py-20"><nav class="mb-4 flex items-center gap-2 text-sm text-muted-foreground"><span class="flex items-center gap-2"><a class="hover:text-foreground transition-colors" href="/blog/">Blog</a></span></nav><h1 class="text-3xl font-extrabold tracking-tight sm:text-4xl lg:text-5xl max-w-3xl">Benchmarks: 1,587x Faster Recursive Queries with Differential Dataflow</h1><p class="mt-4 text-lg text-muted-foreground max-w-2xl">February 15, 2026 Â· InputLayer Team</p></div></div></section><article class="mx-auto max-w-3xl px-6 py-12"><div class="docs-prose"><h1 id="benchmarks-1587x-faster-recursive-queries-with-differential-dataflow" node="[object Object]">Benchmarks: 1,587x Faster Recursive Queries with Differential Dataflow</h1>
<p>When a single fact changes in a knowledge graph with 400,000 derived relationships, how much work should the system do?</p>
<p>The naive answer: recompute all 400,000 relationships from scratch. That&#x27;s what most systems do. It takes 11 seconds.</p>
<p>The smart answer: figure out which relationships are actually affected by the change and update only those. That takes 6.83 milliseconds.</p>
<p>That&#x27;s a <strong>1,652x</strong> difference. And it&#x27;s the difference between &quot;we can check permissions in real time&quot; and &quot;we run a batch job overnight and hope nothing changes before morning.&quot;</p>
<h2 id="the-benchmark-setup" node="[object Object]">The benchmark setup</h2>
<p>We wanted to test something that reflects real-world usage, not a synthetic micro-benchmark. So we picked a common pattern: computing transitive authority in an organizational graph. This is the same kind of computation you&#x27;d need for access control chains, supply chain risk propagation, or entity resolution across corporate structures.</p>
<div class="my-8 overflow-x-auto"><div class="flex items-center justify-center gap-0 min-w-max px-2"><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">2,000 nodes</div><div class="flex items-center px-1"><div class="w-5 h-px bg-border"></div><div class="w-0 h-0 border-t-[4px] border-b-[4px] border-l-[6px] border-t-transparent border-b-transparent border-l-border"></div></div></div><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">~6,000 edges</div><div class="flex items-center px-1"><div class="w-5 h-px bg-border"></div><div class="w-0 h-0 border-t-[4px] border-b-[4px] border-l-[6px] border-t-transparent border-b-transparent border-l-border"></div></div></div><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">~400,000 derived relationships</div></div></div></div>
<div class="my-8 rounded-r-lg border border-l-4 px-5 py-4 border-l-blue-400 dark:border-l-blue-500 bg-blue-50/60 dark:bg-blue-950/20"><p class="text-sm leading-relaxed whitespace-pre-line">The test: add one new edge, then measure how long it takes to update all derived relationships.</p></div>
<p>The 400,000 derived relationships come from the transitive nature of authority. If A manages B and B manages C, then A has authority over C. Follow that logic through 2,000 nodes with an average depth of 8-10 levels, and the number of derived relationships grows fast.</p>
<h2 id="the-results" node="[object Object]">The results</h2>
<div class="my-4 overflow-x-auto"><table class="w-full border-collapse" node="[object Object]"><thead><tr><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Approach</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Time</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">What it does</th></tr></thead><tbody><tr><td class="border px-4 py-2" node="[object Object]">Full recomputation</td><td class="border px-4 py-2" node="[object Object]">11,280 ms</td><td class="border px-4 py-2" node="[object Object]">Throws away all 400,000 derived relationships, re-derives them all</td></tr><tr><td class="border px-4 py-2" node="[object Object]">InputLayer (incremental)</td><td class="border px-4 py-2" node="[object Object]">6.83 ms</td><td class="border px-4 py-2" node="[object Object]">Identifies affected relationships, updates only those</td></tr></tbody></table></div>
<p>Full recomputation doesn&#x27;t care that you only changed one edge. It treats the entire graph as dirty and rebuilds everything. InputLayer&#x27;s engine, on the other hand, traces the impact of the change through the derivation graph and touches only what&#x27;s affected.</p>
<p>To put 6.83ms in perspective: that&#x27;s fast enough to run inline with an API request. You can check permissions, compute supply chain exposure, or resolve entity relationships at query time rather than pre-computing them in a batch process.</p>
<h2 id="the-scaling-story" node="[object Object]">The scaling story</h2>
<p>Here&#x27;s where it gets really interesting. The incremental advantage doesn&#x27;t stay constant as your graph grows - it gets <em>dramatically</em> better.</p>
<div class="my-4 overflow-x-auto"><table class="w-full border-collapse" node="[object Object]"><thead><tr><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Graph size</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Derived relationships</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Full recompute</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Incremental</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Speedup</th></tr></thead><tbody><tr><td class="border px-4 py-2" node="[object Object]">500 nodes</td><td class="border px-4 py-2" node="[object Object]">~25,000</td><td class="border px-4 py-2" node="[object Object]">420 ms</td><td class="border px-4 py-2" node="[object Object]">1.2 ms</td><td class="border px-4 py-2" node="[object Object]"><strong>350x</strong></td></tr><tr><td class="border px-4 py-2" node="[object Object]">1,000 nodes</td><td class="border px-4 py-2" node="[object Object]">~100,000</td><td class="border px-4 py-2" node="[object Object]">2,800 ms</td><td class="border px-4 py-2" node="[object Object]">3.1 ms</td><td class="border px-4 py-2" node="[object Object]"><strong>903x</strong></td></tr><tr><td class="border px-4 py-2" node="[object Object]">2,000 nodes</td><td class="border px-4 py-2" node="[object Object]">~400,000</td><td class="border px-4 py-2" node="[object Object]">11,280 ms</td><td class="border px-4 py-2" node="[object Object]">6.83 ms</td><td class="border px-4 py-2" node="[object Object]"><strong>1,652x</strong></td></tr></tbody></table></div>
<p>Look at how the two columns grow. Full recomputation grows roughly quadratically - double the nodes, quadruple the time. But incremental updates grow much slower, because most single-fact changes only ripple through a small portion of the graph.</p>
<div class="my-8"><div class="flex gap-3.5"><div class="flex flex-col items-center"><div class="w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shrink-0 ring-2 bg-muted text-muted-foreground ring-border">1</div><div class="w-px flex-1 min-h-5 bg-border/60"></div></div><div class="pb-5 pt-1 min-w-0"><p class="text-sm font-medium leading-snug">500 nodes: 420ms full vs 1.2ms incremental</p><p class="text-xs text-muted-foreground mt-0.5 leading-snug">350x faster</p></div></div><div class="flex gap-3.5"><div class="flex flex-col items-center"><div class="w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shrink-0 ring-2 bg-muted text-muted-foreground ring-border">2</div><div class="w-px flex-1 min-h-5 bg-border/60"></div></div><div class="pb-5 pt-1 min-w-0"><p class="text-sm font-medium leading-snug">1,000 nodes: 2,800ms full vs 3.1ms incremental</p><p class="text-xs text-muted-foreground mt-0.5 leading-snug">903x faster</p></div></div><div class="flex gap-3.5"><div class="flex flex-col items-center"><div class="w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shrink-0 ring-2 bg-primary/20 text-primary ring-primary/40">3</div></div><div class="pb-5 pt-1 min-w-0"><p class="text-sm font-medium leading-snug">2,000 nodes: 11,280ms full vs 6.83ms incremental</p><p class="text-xs text-muted-foreground mt-0.5 leading-snug">1,652x faster</p></div></div></div>
<p>This scaling behavior is fundamental, not accidental. Full recomputation has to process the entire graph regardless of what changed. Incremental updates process only the &quot;blast radius&quot; of the change, which stays relatively small even as the total graph grows.</p>
<p>At 10,000 nodes, the full recompute would take over a minute. The incremental update would still be in the low tens of milliseconds. That&#x27;s the difference between a feature that&#x27;s practical in production and one that isn&#x27;t.</p>
<h2 id="why-the-numbers-work-this-way" node="[object Object]">Why the numbers work this way</h2>
<p>InputLayer is built on <a href="https://github.com/TimelyDataflow/differential-dataflow" target="_blank" rel="noopener noreferrer" node="[object Object]">Differential Dataflow</a>, a Rust library for incremental computation created by Frank McSherry. The core idea is simple: instead of storing derived results as static data, the engine represents everything as <em>differences</em> that can be efficiently passed along.</p>
<p>Here&#x27;s how a fact change flows through the system:</p>
<div class="my-8 flex flex-col items-center gap-0"><div class="rounded-lg border px-5 py-2.5 text-sm text-center max-w-xs w-full shadow-sm bg-card border-border">You add an edge: &quot;Diana manages Eve&quot;</div><div class="flex flex-col items-center py-0.5"><div class="w-px h-2.5 bg-border"></div><span class="text-[11px] text-muted-foreground leading-tight py-px">who has authority over Diana?</span><div class="w-px h-2.5 bg-border"></div><div class="w-0 h-0 border-l-[5px] border-r-[5px] border-t-[6px] border-l-transparent border-r-transparent border-t-border"></div></div><div class="rounded-lg border px-5 py-2.5 text-sm text-center max-w-xs w-full shadow-sm bg-primary/10 border-primary/60">Engine finds: Alice and Bob (from existing derivations)</div><div class="flex flex-col items-center py-0.5"><div class="w-px h-2.5 bg-border"></div><span class="text-[11px] text-muted-foreground leading-tight py-px">so they must also have authority over Eve</span><div class="w-px h-2.5 bg-border"></div><div class="w-0 h-0 border-l-[5px] border-r-[5px] border-t-[6px] border-l-transparent border-r-transparent border-t-border"></div></div><div class="rounded-lg border px-5 py-2.5 text-sm text-center max-w-xs w-full shadow-sm bg-card border-border">Engine checks: does Eve manage anyone? Yes - Frank</div><div class="flex flex-col items-center py-0.5"><div class="w-px h-2.5 bg-border"></div><span class="text-[11px] text-muted-foreground leading-tight py-px">so Alice and Bob also get authority over Frank</span><div class="w-px h-2.5 bg-border"></div><div class="w-0 h-0 border-l-[5px] border-r-[5px] border-t-[6px] border-l-transparent border-r-transparent border-t-border"></div></div><div class="rounded-lg border px-5 py-2.5 text-sm text-center max-w-xs w-full shadow-sm bg-emerald-50 dark:bg-emerald-950/30 border-emerald-300 dark:border-emerald-800 text-emerald-800 dark:text-emerald-200">Engine checks: does Frank manage anyone? No. Done.</div><div class="rounded-lg px-5 py-2.5 text-sm text-center max-w-xs w-full shadow-sm bg-primary/10 border-2 border-primary font-medium">Total work: 4 new derived relationships in ~2ms</div></div>
<p>The engine didn&#x27;t scan the entire graph. It didn&#x27;t recompute relationships for nodes that weren&#x27;t affected. It started from the change, followed the ripple effects, and stopped as soon as the ripple died out.</p>
<p>For recursive reasoning - like transitive authority where conclusions feed back into the computation - the engine runs a loop until it reaches a stable point where no new differences are produced. When something changes later, it re-enters that loop at the point of change and computes only the new differences.</p>
<p>InputLayer also uses a technique called Magic Sets that makes queries demand-driven. When you ask &quot;who does Alice have authority over?&quot;, the engine doesn&#x27;t compute authority for every person in the organization. It starts from Alice and follows only the relevant paths. Query time becomes proportional to Alice&#x27;s portion of the graph, not the entire organization.</p>
<h2 id="correct-retraction-the-hard-part" node="[object Object]">Correct retraction: the hard part</h2>
<p>Adding facts is relatively straightforward to handle incrementally. Removing them is where things get genuinely hard.</p>
<p>Say Alice has authority over Charlie through two independent paths:</p>
<div class="my-8 overflow-x-auto"><div class="flex items-center justify-center gap-0 min-w-max px-2"><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">Alice</div><div class="flex items-center px-1"><div class="w-5 h-px bg-border"></div><div class="w-0 h-0 border-t-[4px] border-b-[4px] border-l-[6px] border-t-transparent border-b-transparent border-l-border"></div></div></div><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">Bob</div><div class="flex items-center px-1"><div class="w-5 h-px bg-border"></div><div class="w-0 h-0 border-t-[4px] border-b-[4px] border-l-[6px] border-t-transparent border-b-transparent border-l-border"></div></div></div><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-primary/10 border-primary/60">Charlie</div></div></div></div>
<div class="my-8 overflow-x-auto"><div class="flex items-center justify-center gap-0 min-w-max px-2"><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">Alice</div><div class="flex items-center px-1"><div class="w-5 h-px bg-border"></div><div class="w-0 h-0 border-t-[4px] border-b-[4px] border-l-[6px] border-t-transparent border-b-transparent border-l-border"></div></div></div><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-card border-border">Diana</div><div class="flex items-center px-1"><div class="w-5 h-px bg-border"></div><div class="w-0 h-0 border-t-[4px] border-b-[4px] border-l-[6px] border-t-transparent border-b-transparent border-l-border"></div></div></div><div class="flex items-center shrink-0"><div class="rounded-lg border px-4 py-2 text-sm shadow-sm whitespace-nowrap bg-primary/10 border-primary/60">Charlie</div></div></div></div>
<p>If you remove Bob&#x27;s management of Charlie, Alice should still have authority over Charlie through Diana. But if you remove Diana&#x27;s management of Charlie too, the authority should disappear entirely.</p>
<p>The engine tracks this through weighted differences. Each derived relationship has a weight based on the number of independent paths that support it. When a path is removed, the weight goes down. Only when it reaches zero does the conclusion go away.</p>
<div class="my-8"><div class="flex gap-3.5"><div class="flex flex-col items-center"><div class="w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shrink-0 ring-2 bg-muted text-muted-foreground ring-border">1</div><div class="w-px flex-1 min-h-5 bg-border/60"></div></div><div class="pb-5 pt-1 min-w-0"><p class="text-sm font-medium leading-snug">Both paths exist: authority(Alice, Charlie) weight is 2</p><p class="text-xs text-muted-foreground mt-0.5 leading-snug">via Bob and Diana</p></div></div><div class="flex gap-3.5"><div class="flex flex-col items-center"><div class="w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shrink-0 ring-2 bg-emerald-100 dark:bg-emerald-900/50 text-emerald-700 dark:text-emerald-300 ring-emerald-300 dark:ring-emerald-700">2</div><div class="w-px flex-1 min-h-5 bg-border/60"></div></div><div class="pb-5 pt-1 min-w-0"><p class="text-sm font-medium leading-snug">Remove Bob to Charlie: weight drops to 1</p><p class="text-xs text-muted-foreground mt-0.5 leading-snug">still exists via Diana</p></div></div><div class="flex gap-3.5"><div class="flex flex-col items-center"><div class="w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shrink-0 ring-2 bg-red-100 dark:bg-red-900/50 text-red-700 dark:text-red-300 ring-red-300 dark:ring-red-700">3</div></div><div class="pb-5 pt-1 min-w-0"><p class="text-sm font-medium leading-snug">Remove Diana to Charlie: weight drops to 0</p><p class="text-xs text-muted-foreground mt-0.5 leading-snug">retracted</p></div></div></div>
<p>On our benchmark graph, retracting a single edge and propagating all downstream changes takes under 10ms. Bulk retractions (removing 100 edges) complete in about a second. Fast enough for real-time applications where facts change frequently.</p>
<h2 id="what-this-means-in-practice" node="[object Object]">What this means in practice</h2>
<p>The practical takeaway here is about which architectural patterns become possible.</p>
<p><strong>Without incremental computation</strong>, you&#x27;re stuck with batch processing. Pre-compute permissions overnight. Rebuild recommendation indexes hourly. Re-run compliance checks on a schedule. And accept that between runs, your derived data is stale.</p>
<p><strong>With incremental computation</strong>, you can do these things live:</p>
<div class="my-4 overflow-x-auto"><table class="w-full border-collapse" node="[object Object]"><thead><tr><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Use case</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Batch approach</th><th class="border px-4 py-2 text-left font-semibold bg-muted/50" node="[object Object]">Incremental approach</th></tr></thead><tbody><tr><td class="border px-4 py-2" node="[object Object]">Access control</td><td class="border px-4 py-2" node="[object Object]">Nightly permission rebuild</td><td class="border px-4 py-2" node="[object Object]">Live permission check at query time</td></tr><tr><td class="border px-4 py-2" node="[object Object]">Supply chain risk</td><td class="border px-4 py-2" node="[object Object]">Hourly risk recalculation</td><td class="border px-4 py-2" node="[object Object]">Instant risk update when a supplier status changes</td></tr><tr><td class="border px-4 py-2" node="[object Object]">Compliance screening</td><td class="border px-4 py-2" node="[object Object]">Daily sanctions check</td><td class="border px-4 py-2" node="[object Object]">Real-time flag when ownership structure changes</td></tr><tr><td class="border px-4 py-2" node="[object Object]">Recommendations</td><td class="border px-4 py-2" node="[object Object]">Model retrain every few hours</td><td class="border px-4 py-2" node="[object Object]">Instant update when user behavior or inventory changes</td></tr></tbody></table></div>
<p>The 1,652x speedup isn&#x27;t about making a slow thing faster. It&#x27;s about making batch-only workloads work in real time. That&#x27;s a qualitative difference in what you can build.</p>
<h2 id="try-it-yourself" node="[object Object]">Try it yourself</h2>
<p>InputLayer is open-source:</p>
<pre class="rounded-lg bg-[var(--code-bg)] p-4 overflow-x-auto mb-4 text-sm font-mono" node="[object Object]"><code class="language-bash text-sm"><span class="syn-builtin">docker</span> run <span class="syn-meta">-p</span> 8080:8080 ghcr.io/inputlayer/inputlayer</code></pre>
<p>Start with the <a node="[object Object]" href="/docs/guides/quickstart/">quickstart guide</a> to build your first knowledge graph, or dive into the <a node="[object Object]" href="/docs/guides/recursion/">recursion documentation</a> to see how recursive reasoning works under the hood.</p></div></article><section class="border-t border-border/50"><div class="mx-auto max-w-6xl px-6 py-16"><div class="relative rounded-2xl border border-border bg-gradient-to-br from-primary/10 via-transparent to-primary/5 p-12 text-center space-y-6"><h2 class="text-3xl font-bold tracking-tight">Ready to get started?</h2><p class="text-muted-foreground text-lg max-w-xl mx-auto">InputLayer is open-source. Pull the Docker image and start building.</p><div class="flex flex-wrap justify-center gap-3 pt-2"><a class="inline-flex items-center gap-2 rounded-md bg-primary px-6 py-3 text-sm font-medium text-primary-foreground hover:bg-primary/90 transition-colors" href="/docs/">Read the docs<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right h-4 w-4"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></a><a href="https://github.com/inputlayer/inputlayer" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 rounded-md border border-border bg-background px-6 py-3 text-sm font-medium hover:bg-secondary transition-colors">View on GitHub<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3.5 w-3.5"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></div></div></div></section></main><footer class="border-t border-border/50 bg-card/50"><div class="mx-auto max-w-6xl px-6 py-12"><div class="grid grid-cols-2 gap-8 md:grid-cols-4 lg:gap-12"><div><h3 class="text-sm font-semibold text-foreground mb-3">Product</h3><ul class="space-y-2"><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/#features">Features</a></li><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/use-cases/">Use Cases</a></li><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/compare/">Compare</a></li><li><a href="https://demo.inputlayer.ai" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors">Demo<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3 w-3"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></li></ul></div><div><h3 class="text-sm font-semibold text-foreground mb-3">Resources</h3><ul class="space-y-2"><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/docs/">Documentation</a></li><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/blog/">Blog</a></li><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/docs/guides/quickstart/">Quickstart</a></li><li><a class="text-sm text-muted-foreground hover:text-foreground transition-colors" href="/docs/guides/python-sdk/">Python SDK</a></li></ul></div><div><h3 class="text-sm font-semibold text-foreground mb-3">Company</h3><ul class="space-y-2"><li><a href="https://github.com/inputlayer/inputlayer" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors">GitHub<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3 w-3"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></li><li><a href="https://github.com/inputlayer/inputlayer/blob/main/LICENSE" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors">License<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3 w-3"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></li></ul></div><div><h3 class="text-sm font-semibold text-foreground mb-3">Community</h3><ul class="space-y-2"><li><a href="https://github.com/inputlayer/inputlayer" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors">Star on GitHub<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3 w-3"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></li><li><a href="https://github.com/inputlayer/inputlayer/blob/main/CONTRIBUTING.md" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors">Contributing<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-external-link h-3 w-3"><path d="M15 3h6v6"></path><path d="M10 14 21 3"></path><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path></svg></a></li></ul></div></div><div class="mt-10 flex flex-col sm:flex-row items-center justify-between gap-4 border-t border-border/50 pt-8"><div class="flex items-center gap-4"><span class="inline-flex items-center gap-1.5"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="flex-shrink-0"><path d="M12 2L2 7l10 5 10-5-10-5z"></path><path d="M2 17l10 5 10-5"></path><path d="M2 12l10 5 10-5"></path></svg><span class="font-extrabold tracking-tight text-base">InputLayer</span></span><span class="text-sm text-muted-foreground">AGPL-3.0 License</span></div><p class="text-xs text-muted-foreground">A symbolic reasoning engine for AI agents.</p></div></div></footer></div><!--$--><!--/$--><script src="/_next/static/chunks/webpack-bd6546b43ab2ecbf.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[1942,[\"177\",\"static/chunks/app/layout-7e9963bf811be36b.js\"],\"ThemeProvider\"]\n3:I[7121,[],\"\"]\n4:I[4581,[],\"\"]\n6:I[484,[],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[484,[],\"ViewportBoundary\"]\nb:I[484,[],\"MetadataBoundary\"]\nd:I[7123,[],\"\"]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/4bd7a24b7976d4e6.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"05bjYGyiAumoEMBrfWHih\",\"c\":[\"\",\"blog\",\"benchmarks-1587x-faster-recursive-queries\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"benchmarks-1587x-faster-recursive-queries\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4bd7a24b7976d4e6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_188709 __variable_9a8899 font-sans antialiased\",\"children\":[\"$\",\"$L2\",null,{\"attribute\":\"class\",\"defaultTheme\":\"dark\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$@a\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@c\"}]}]}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:I[1268,[\"758\",\"static/chunks/758-3cb69ce377cde046.js\",\"121\",\"static/chunks/121-aece4f809b101dc1.js\",\"830\",\"static/chunks/830-dbae36b1030f3d7c.js\",\"689\",\"static/chunks/689-4fcf9680fdc90283.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-a68506d98e2282cb.js\"],\"BlogPostClient\"]\nf:T1f32,"])</script><script>self.__next_f.push([1,"\n# Benchmarks: 1,587x Faster Recursive Queries with Differential Dataflow\n\nWhen a single fact changes in a knowledge graph with 400,000 derived relationships, how much work should the system do?\n\nThe naive answer: recompute all 400,000 relationships from scratch. That's what most systems do. It takes 11 seconds.\n\nThe smart answer: figure out which relationships are actually affected by the change and update only those. That takes 6.83 milliseconds.\n\nThat's a **1,652x** difference. And it's the difference between \"we can check permissions in real time\" and \"we run a batch job overnight and hope nothing changes before morning.\"\n\n## The benchmark setup\n\nWe wanted to test something that reflects real-world usage, not a synthetic micro-benchmark. So we picked a common pattern: computing transitive authority in an organizational graph. This is the same kind of computation you'd need for access control chains, supply chain risk propagation, or entity resolution across corporate structures.\n\n```flow\n2,000 nodes -\u003e ~6,000 edges -\u003e ~400,000 derived relationships\n```\n\n```note\ntype: info\nThe test: add one new edge, then measure how long it takes to update all derived relationships.\n```\n\nThe 400,000 derived relationships come from the transitive nature of authority. If A manages B and B manages C, then A has authority over C. Follow that logic through 2,000 nodes with an average depth of 8-10 levels, and the number of derived relationships grows fast.\n\n## The results\n\n| Approach | Time | What it does |\n|---|---|---|\n| Full recomputation | 11,280 ms | Throws away all 400,000 derived relationships, re-derives them all |\n| InputLayer (incremental) | 6.83 ms | Identifies affected relationships, updates only those |\n\nFull recomputation doesn't care that you only changed one edge. It treats the entire graph as dirty and rebuilds everything. InputLayer's engine, on the other hand, traces the impact of the change through the derivation graph and touches only what's affected.\n\nTo put 6.83ms in perspective: that's fast enough to run inline with an API request. You can check permissions, compute supply chain exposure, or resolve entity relationships at query time rather than pre-computing them in a batch process.\n\n## The scaling story\n\nHere's where it gets really interesting. The incremental advantage doesn't stay constant as your graph grows - it gets *dramatically* better.\n\n| Graph size | Derived relationships | Full recompute | Incremental | Speedup |\n|---|---|---|---|---|\n| 500 nodes | ~25,000 | 420 ms | 1.2 ms | **350x** |\n| 1,000 nodes | ~100,000 | 2,800 ms | 3.1 ms | **903x** |\n| 2,000 nodes | ~400,000 | 11,280 ms | 6.83 ms | **1,652x** |\n\nLook at how the two columns grow. Full recomputation grows roughly quadratically - double the nodes, quadruple the time. But incremental updates grow much slower, because most single-fact changes only ripple through a small portion of the graph.\n\n```steps\n500 nodes: 420ms full vs 1.2ms incremental :: 350x faster\n1,000 nodes: 2,800ms full vs 3.1ms incremental :: 903x faster\n2,000 nodes: 11,280ms full vs 6.83ms incremental :: 1,652x faster [primary]\n```\n\nThis scaling behavior is fundamental, not accidental. Full recomputation has to process the entire graph regardless of what changed. Incremental updates process only the \"blast radius\" of the change, which stays relatively small even as the total graph grows.\n\nAt 10,000 nodes, the full recompute would take over a minute. The incremental update would still be in the low tens of milliseconds. That's the difference between a feature that's practical in production and one that isn't.\n\n## Why the numbers work this way\n\nInputLayer is built on [Differential Dataflow](https://github.com/TimelyDataflow/differential-dataflow), a Rust library for incremental computation created by Frank McSherry. The core idea is simple: instead of storing derived results as static data, the engine represents everything as *differences* that can be efficiently passed along.\n\nHere's how a fact change flows through the system:\n\n```chain\nYou add an edge: \"Diana manages Eve\"\n-- who has authority over Diana?\nEngine finds: Alice and Bob (from existing derivations) [primary]\n-- so they must also have authority over Eve\nEngine checks: does Eve manage anyone? Yes - Frank\n-- so Alice and Bob also get authority over Frank\nEngine checks: does Frank manage anyone? No. Done. [success]\n=\u003e Total work: 4 new derived relationships in ~2ms\n```\n\nThe engine didn't scan the entire graph. It didn't recompute relationships for nodes that weren't affected. It started from the change, followed the ripple effects, and stopped as soon as the ripple died out.\n\nFor recursive reasoning - like transitive authority where conclusions feed back into the computation - the engine runs a loop until it reaches a stable point where no new differences are produced. When something changes later, it re-enters that loop at the point of change and computes only the new differences.\n\nInputLayer also uses a technique called Magic Sets that makes queries demand-driven. When you ask \"who does Alice have authority over?\", the engine doesn't compute authority for every person in the organization. It starts from Alice and follows only the relevant paths. Query time becomes proportional to Alice's portion of the graph, not the entire organization.\n\n## Correct retraction: the hard part\n\nAdding facts is relatively straightforward to handle incrementally. Removing them is where things get genuinely hard.\n\nSay Alice has authority over Charlie through two independent paths:\n\n```flow\nAlice -\u003e Bob -\u003e Charlie [primary]\n```\n\n```flow\nAlice -\u003e Diana -\u003e Charlie [primary]\n```\n\nIf you remove Bob's management of Charlie, Alice should still have authority over Charlie through Diana. But if you remove Diana's management of Charlie too, the authority should disappear entirely.\n\nThe engine tracks this through weighted differences. Each derived relationship has a weight based on the number of independent paths that support it. When a path is removed, the weight goes down. Only when it reaches zero does the conclusion go away.\n\n```steps\nBoth paths exist: authority(Alice, Charlie) weight is 2 :: via Bob and Diana\nRemove Bob to Charlie: weight drops to 1 :: still exists via Diana [success]\nRemove Diana to Charlie: weight drops to 0 :: retracted [highlight]\n```\n\nOn our benchmark graph, retracting a single edge and propagating all downstream changes takes under 10ms. Bulk retractions (removing 100 edges) complete in about a second. Fast enough for real-time applications where facts change frequently.\n\n## What this means in practice\n\nThe practical takeaway here is about which architectural patterns become possible.\n\n**Without incremental computation**, you're stuck with batch processing. Pre-compute permissions overnight. Rebuild recommendation indexes hourly. Re-run compliance checks on a schedule. And accept that between runs, your derived data is stale.\n\n**With incremental computation**, you can do these things live:\n\n| Use case | Batch approach | Incremental approach |\n|---|---|---|\n| Access control | Nightly permission rebuild | Live permission check at query time |\n| Supply chain risk | Hourly risk recalculation | Instant risk update when a supplier status changes |\n| Compliance screening | Daily sanctions check | Real-time flag when ownership structure changes |\n| Recommendations | Model retrain every few hours | Instant update when user behavior or inventory changes |\n\nThe 1,652x speedup isn't about making a slow thing faster. It's about making batch-only workloads work in real time. That's a qualitative difference in what you can build.\n\n## Try it yourself\n\nInputLayer is open-source:\n\n```bash\ndocker run -p 8080:8080 ghcr.io/inputlayer/inputlayer\n```\n\nStart with the [quickstart guide](/docs/guides/quickstart/) to build your first knowledge graph, or dive into the [recursion documentation](/docs/guides/recursion/) to see how recursive reasoning works under the hood."])</script><script>self.__next_f.push([1,"5:[\"$\",\"$Le\",null,{\"post\":{\"slug\":\"benchmarks-1587x-faster-recursive-queries\",\"title\":\"Benchmarks: 1,587x Faster Recursive Queries with Differential Dataflow\",\"date\":\"2026-02-15\",\"author\":\"InputLayer Team\",\"category\":\"Engineering\",\"excerpt\":\"How InputLayer's incremental computation engine delivers sub-millisecond updates on recursive queries over large graphs. The architecture behind the numbers.\",\"content\":\"$f\",\"toc\":[{\"level\":2,\"text\":\"The benchmark setup\",\"id\":\"the-benchmark-setup\"},{\"level\":2,\"text\":\"The results\",\"id\":\"the-results\"},{\"level\":2,\"text\":\"The scaling story\",\"id\":\"the-scaling-story\"},{\"level\":2,\"text\":\"Why the numbers work this way\",\"id\":\"why-the-numbers-work-this-way\"},{\"level\":2,\"text\":\"Correct retraction: the hard part\",\"id\":\"correct-retraction-the-hard-part\"},{\"level\":2,\"text\":\"What this means in practice\",\"id\":\"what-this-means-in-practice\"},{\"level\":2,\"text\":\"Try it yourself\",\"id\":\"try-it-yourself\"}]},\"slug\":\"benchmarks-1587x-faster-recursive-queries\"}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"10:I[6869,[],\"IconMark\"]\nc:[[\"$\",\"title\",\"0\",{\"children\":\"InputLayer - A symbolic reasoning engine for AI agents\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Store facts, define rules, and derive everything that logically follows. Vector search, graph traversal, and incremental computation in one system.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/icon.svg\"}],[\"$\",\"$L10\",\"3\",{}]]\n8:null\n"])</script></body></html>